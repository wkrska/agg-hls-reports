[{"path":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/agg.h", "name":"agg.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/agg.h", "content":"#ifndef AGG_H\u000A#define AGG_H\u000A\u000A#include \"debug.h\"\u000A#include \"types.h\"\u000A\u000A#define _B_                                                                    \\\u000A  (8) // Number of tuples received/emitted per cycle on the data bus\u000A      // (i.e., the line rate) This isn't used by this project (just\u000A      // reading test input from DRAM\u000A\u000A#ifndef _S_\u000A#define _S_ (1) // Number of computational cores (the scaling factor)\u000A#endif\u000A\u000A#ifndef _P_\u000A#define _P_ (4) // Like S,except these cores are lockstepped\u000A#endif\u000A\u000A#ifndef _N_\u000A#define _N_ (4) // Input width of each computational core. We choose N = 4.\u000A#endif\u000A\u000A#ifndef _G_\u000A#define _G_                                                                    \\\u000A  (64) // Number of aggregation groups the computational core is configured for\u000A       // (4 to 64)\u000A#endif\u000A\u000A#define _I_                                                                    \\\u000A  ((_N_) * (_S_) *                                                             \\\u000A   (_P_)) // Total number of input tuples processed in each cycle = SxN\u000A\u000A#define _O_                                                                    \\\u000A  ((_S_) * (_P_) *                                                             \\\u000A   (_G_)) // Total Total number of tuples created by local aggregation = SxG\u000A\u000Atypedef unsigned int AggKey;\u000Atypedef unsigned int AggVal;\u000A\u000Astruct Tuple {\u000A  BOOL valid;\u000A  AggKey key;\u000A  AggVal val;\u000A};\u000A\u000A//\u000A// Tuple padded to 16-bytes\u000A//\u000Astruct TuplePadded16 {\u000A  UINT valid;\u000A  AggKey key;\u000A  AggVal val;\u000A  UINT pad;\u000A};\u000A\u000A// a cam table will translate a key\u000A// to its table location\u000Atypedef unsigned short AggTblIdx;\u000A\u000A#endif\u000A"}, {"path":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/core.h", "name":"core.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/core.h", "content":"// Core functions implementing a stream key-value aggregator as\u000A// described in \"FPGA for Aggregate Processing: The Good, The Bad, and\u000A// The Ugly\".\u000A\u000A#ifndef CORE_H\u000A#define CORE_H\u000A\u000A#include <cstdio>\u000A#include <cstdlib>\u000A#ifndef CXXONLY\u000A#include <sycl/sycl.hpp>\u000A#endif\u000A\u000A#include \"agg.h\"\u000A#include \"debug.h\"\u000A#include \"types.h\"\u000A\u000A// The following is used by a hack to work around a compiler issue\u000A// until next release. 1D array declared in structs has to be declared\u000A// as 2D to map to registers.\u000A#define ONE (1)\u000A#define ZERO (0)\u000A\u000A// Takes in TNumTuple KV pairs and returns up to TNumTuple KV\u000A// pairs. Input pairs with common keys are combined into one by\u000A// summing their values.  Absorbed positions are marked invalid.\u000Atemplate <int TNumTuple, int TNumGroup>\u000Avoid collectTuples(\u000A    // input\u000A    Tuple in[TNumTuple],\u000A\u000A    // output\u000A    Tuple uniq[TNumTuple]) {\u000A\u000A  // initialize default\u000A#pragma unroll\u000A  for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A    uniq[tup].valid = in[tup].valid;\u000A    uniq[tup].key = in[tup].key;\u000A  }\u000A\u000A  // N^2 / 2 comparisons to collect common key pairs\u000A#pragma unroll\u000A  for (UIDX i = 0; i < TNumTuple; i++) {\u000A    uniq[i].val = in[i].val;\u000A#pragma unroll\u000A    for (UIDX j = i + 1; j < TNumTuple; j++) {\u000A      if (in[i].valid && in[j].valid && (in[i].key == in[j].key)) {\u000A        uniq[j].valid = false;    // invalid absorbed position\u000A        uniq[i].val += in[j].val; // absorb value\u000A      }\u000A    }\u000A  }\u000A}\u000A\u000A// Translate TNumTuples to their allocated table locations.  Allocate\u000A// new location when seeing a key for the first time. This implements\u000A// a systolic array with O(G) delay but fixed FMAX independent of\u000A// G.\u000A\u000A// There is a compiler quirkiness having to do with adding banking\u000A// directives to \"struct with arrays\" and/or \"array of structs\". The\u000A// table array has to be declared flat, outside of a struct/class. To\u000A// be revisited in the future.\u000A\u000A// The macros below is a clumsy way of making things a little easier\u000A// to use since we can't make a proper class.\u000A#define MAPPER_DECLARE(P, N, G, O)                                             \\\u000A  [[intel::fpga_register]] AggKey __camKey[(P)][(G)] = {};                     \\\u000A  [[intel::fpga_register]] BOOL __camValid[(P)][(G)] = {};                     \\\u000A  CoreKeyMapper<(P), (N), (G), (O)> __mapper;\u000A\u000A#define MAPPER_MAP(flush, it, ii, im, oi, om, p)                               \\\u000A  __mapper.map((flush), (it), (ii), (im), (oi), (om), __camKey, __camValid,    \\\u000A               (p));\u000A\u000Atemplate <int TNumPipeline, int TNumTuple, int TNumGroup, int TOffset>\u000Astruct CoreKeyMapper {\u000A  //\u000A  // CAM map table array to be implemented as registers\u000A  //\u000A\u000A  // map key to index; allocate on the fly; deep pipelining streaming\u000A  // CAM lookup\u000A  void map(\u000A      // input\u000A      BOOL flush,\u000A      Tuple uniqIn[TNumTuple],    // cannot have duplicate keys\u000A      AggTblIdx idxIn[TNumTuple], // from upstream translated linear index for\u000A                                  // valid tuples\u000A      BOOL mappedIn[TNumTuple],\u000A\u000A      // output\u000A      AggTblIdx\u000A          idxOut[TNumTuple], // output translated linear index for valid tuples\u000A      BOOL mappedOut[TNumTuple],\u000A\u000A      // STATE\u000A      AggKey camKey[TNumPipeline][TNumGroup],\u000A      BOOL camValid[TNumPipeline][TNumGroup],\u000A\u000A      // STATE idx\u000A      UIDX ppln) {\u000A#pragma unroll\u000A    for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A      // in cascade mode, transfer already mapped indices\u000A      idxOut[tup] = idxIn[tup];\u000A      mappedOut[tup] = mappedIn[tup];\u000A    }\u000A\u000A    // CAM populated from 0 to G-1\u000A#pragma unroll\u000A    for (UIDX grp = 0; grp < TNumGroup; grp++) {\u000A      // this unrolls into very deep cascaded stages; CAM lookup is\u000A      // serialized and pipelined across by the lookup stream.\u000A      if (camValid[ppln][grp]) {\u000A        // on a valid location, try mapping\u000A#pragma unroll\u000A        for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A          if (uniqIn[tup].valid && camValid[ppln][grp] &&\u000A              (uniqIn[tup].key == camKey[ppln][grp])) {\u000A            mappedOut[tup] = true;\u000A            idxOut[tup] = grp + TOffset * TNumGroup;\u000A          }\u000A        }\u000A      } else {\u000A#pragma unroll\u000A        for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A          if (uniqIn[tup].valid && !mappedOut[tup]) {\u000A            // if still not mapped after exhausting previous keys;\u000A            // allocate a new one\u000A            camValid[ppln][grp] = true;\u000A            camKey[ppln][grp] = uniqIn[tup].key;\u000A            mappedOut[tup] = true;\u000A            idxOut[tup] = grp + TOffset * TNumGroup;\u000A            break; // go to next location for remaining unmapped\u000A                   // tuples\u000A          }\u000A        }\u000A      }\u000A      if (flush) {\u000A        camValid[ppln][grp] = false;\u000A        // camKey[ppln][grp] = uniqIn[tup].key;\u000A      }\u000A    }\u000A    return;\u000A  }\u000A};\u000A\u000A// Aggregate into linearly indexed table.  Unlike V0, this version\u000A// uses N-copies of 1R1W parallel tables to accumulate separately for\u000A// each tuple lane. These N tables made from BRAM are much\u000A// cheaper/faster than using only 1 table (NR+NW) made from registers.\u000A\u000A// There is a compiler quirkiness having to do with adding banking\u000A// directives to \"struct with arrays\" and/or \"array of structs\". The\u000A// table array has to be declared flat, outside of a struct/class. To\u000A// be revisited in the future.\u000A\u000A// The macros below is a clumsy way of making things a little easier\u000A// to use since we can't make a proper class.\u000A#define TWOPOWsmall(N)                                                         \\\u000A  (((N) <= 2)                                                                  \\\u000A       ? (N)                                                                   \\\u000A       : (((N) <= 4)                                                           \\\u000A              ? 4                                                              \\\u000A              : (((N) <= 8)                                                    \\\u000A                     ? 8                                                       \\\u000A                     : (((N) <= 16)                                            \\\u000A                            ? 16                                               \\\u000A                            : (((N) <= 32) ? 32                                \\\u000A                                           : (((N) <= 64) ? 64 : (N)))))))\u000A\u000A#define AGG_DECLARE(P, N, G)                                                   \\\u000A  [[intel::fpga_memory(\"BLOCK_RAM\"), intel::singlepump,                        \\\u000A    intel::simple_dual_port /*, intel::bankwidth(sizeof(TuplePadded16)),       \\\u000A                              intel::max_replicates(1),                        \\\u000A                              intel::numbanks((N)*TWOPOWsmall(P))*/            \\\u000A  ]] TuplePadded16 __table[(G)][TWOPOWsmall(P)][(N)];                          \\\u000A  [[intel::fpga_register]] TuplePadded16 __deferred[(P)][2][(N)] = {};         \\\u000A  [[intel::fpga_register]] AggTblIdx __deferredIdx[(P)][2][(N)] = {};          \\\u000A  [[intel::fpga_register]] CoreAggregator<(P), (N), (G)> __agg;\u000A\u000A#define AGG_ZERO_TABLE() __agg.zero(__table)\u000A\u000A#define AGG_UPDATE(t, i, p)                                                    \\\u000A  __agg.update((t), (i), __table, __deferred, __deferredIdx, (p))\u000A\u000A#define AGG_READ(idx, tups) __agg.read(idx, tups, __table)\u000A\u000Atemplate <int TNumPipeline, int TNumTuple, int TNumGroup>\u000Astruct CoreAggregator {\u000A\u000A  // states has to live outside unfortunately.\u000A\u000A  // BRAM array can't be zero by \"={}\";\u000A  void zero(\u000A      // STATE\u000A      TuplePadded16 table[TNumGroup][TWOPOWsmall(TNumPipeline)][TNumTuple]) {\u000A\u000A    MY_ASSERT(\u000A        !((TWOPOWsmall(TNumPipeline) - 1) &\u000A          (TWOPOWsmall(TNumPipeline)))); // TWOPOWsmall only cover small values\u000A\u000A    [[intel::disable_loop_pipelining]] for (UIDX grp = 0; grp < TNumGroup;\u000A                                            grp++) {\u000A#pragma unroll\u000A      for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A#pragma unroll\u000A        for (UIDX tub = 0; tub < TNumTuple; tub++) {\u000A          TuplePadded16 empty = {};\u000A          table[grp][ppln][tub] = empty;\u000A        }\u000A      }\u000A    }\u000A  }\u000A\u000A  void update(\u000A      // input\u000A      Tuple in[TNumTuple],      // unique key tuples\u000A      AggTblIdx idx[TNumTuple], // linear idx from mapper stage\u000A\u000A      // STATE passed in by reference\u000A      TuplePadded16 table[TNumGroup][TWOPOWsmall(TNumPipeline)][TNumTuple],\u000A      TuplePadded16 deferred[TWOPOWsmall(TNumPipeline)][2][TNumTuple],\u000A      AggTblIdx deferredIdx[TWOPOWsmall(TNumPipeline)][2][TNumTuple],\u000A\u000A      // STATE idx\u000A      UIDX ppln) {\u000A\u000A    TuplePadded16 update[TNumTuple] = {};\u000A\u000A    {\u000A      BOOL frwd[TNumTuple] = {};\u000A      AggVal frwdVal[TNumTuple];\u000A\u000A      // find forwarding from memoized updates of not yet written\u000A      // (works within lane)\u000A#pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        if ((idx[tup] == deferredIdx[ppln][0][tup]) &&\u000A            deferred[ppln][0][tup].valid) {\u000A          // distance 1 RAW\u000A          MY_ASSERT(in[tup].valid ? in[tup].key == deferred[ppln][0][tup].key\u000A                                  : true);\u000A          frwd[tup] = true;\u000A          frwdVal[tup] = deferred[ppln][0][tup].val;\u000A        } else if ((idx[tup] == deferredIdx[ppln][1][tup]) &&\u000A                   deferred[ppln][1][tup].valid) {\u000A          // distance 2 RAW\u000A          MY_ASSERT(in[tup].valid ? in[tup].key == deferred[ppln][1][tup].key\u000A                                  : true);\u000A          frwd[tup] = true;\u000A          frwdVal[tup] = deferred[ppln][1][tup].val;\u000A        }\u000A      }\u000A\u000A      // compute new table entry value\u000A#pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        TuplePadded16 temp = table[idx[tup]][ppln][tup];\u000A        update[tup].valid = in[tup].valid;\u000A        update[tup].key = in[tup].key; // overwrite okay\u000A        update[tup].val = in[tup].val + (frwd[tup] ? frwdVal[tup] : temp.val);\u000A      }\u000A    }\u000A\u000A#pragma unroll\u000A    for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A      // write deferred updates from 2 iters ago\u000A      if (deferred[ppln][1][tup].valid) {\u000A        table[deferredIdx[ppln][1][tup]][ppln][tup] = deferred[ppln][1][tup];\u000A      }\u000A      // shift\u000A      deferred[ppln][1][tup] = deferred[ppln][0][tup];\u000A      deferredIdx[ppln][1][tup] = deferredIdx[ppln][0][tup];\u000A    }\u000A\u000A#pragma unroll\u000A    for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A      // record deferred updates to next round\u000A      deferred[ppln][0][tup] = update[tup];\u000A      deferredIdx[ppln][0][tup] = idx[tup];\u000A    }\u000A  }\u000A\u000A  // Reading back when finished accumulating\u000A  void read(\u000A      // input\u000A      AggTblIdx idx,\u000A\u000A      // output\u000A      Tuple tuples[TNumPipeline],\u000A\u000A      // STATE\u000A      TuplePadded16 table[TNumGroup][TWOPOWsmall(TNumPipeline)][TNumTuple]) {\u000A// sum across banks to compute total\u000A#pragma unroll\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A#pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        TuplePadded16 temp = table[idx][ppln][tup];\u000A        if (temp.valid) {\u000A          tuples[ppln].valid = true;\u000A          tuples[ppln].key = temp.key; // overwrite okay\u000A          tuples[ppln].val += temp.val;\u000A        }\u000A      }\u000A    }\u000A  }\u000A};\u000A\u000A#ifdef SHOW_DEPRECATED\u000A#include \"core_.h\"\u000A#endif\u000A\u000A#endif\u000A"}, {"path":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/debug.h", "name":"debug.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/debug.h", "content":"#ifndef DEBUG_H\u000A#define DEBUG_H\u000A\u000A#include <cassert>\u000A\u000A#if NO_MY_ASSERT\u000A#define MY_ASSERT(a)                                                           \\\u000A  {}\u000A#else\u000A#define MY_ASSERT(a) (assert(a))\u000A#endif\u000A\u000A//#define SHOW_DEPRECATED\u000A\u000A#endif\u000A"}, {"path":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/main.cpp", "name":"main.cpp", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/main.cpp", "content":"// SETUP TEST CONDITION\u000A#if 1\u000A#define ROUNDS (8)        // number of rounds, reset in between\u000A#define TESTLEN (1 << 16) // number TESTLEN*S*P*N tuples per round\u000A#define OVERRUN                                                                \\\u000A  (3)                // number of distinct keys to\u000A                     // overflow G by; G is the number of\u000A                     // distinct keys supported in fast\u000A                     // path; overflow goes to a slow\u000A                     // path to aggregate\u000A#define OVERSIZE (2) // oversize table for OVERSIZE*G results\u000A#elif 0\u000A#define ROUNDS (8)\u000A#define TESTLEN (1 << 16)\u000A#define OVERRUN (0) // no overflow direct test\u000A#define OVERSIZE (1)\u000A#else\u000A#define ROUNDS (2) // small setup for debug\u000A#define TESTLEN (2)\u000A#define OVERRUN (0)\u000A#define OVERSIZE (1)\u000A#endif\u000A\u000A#include <array>\u000A#include <cstdio>\u000A#include <cstdlib>\u000A#include <iostream>\u000A#include <sycl/sycl.hpp>\u000Ausing namespace sycl;\u000A\u000A#include \"agg.h\"\u000A#include \"core.h\"\u000A#include \"debug.h\"\u000A#include \"pipes.h\"\u000A#include \"stages.h\"\u000A#include \"types.h\"\u000A\u000A//////////////////////////////////////////////////////////////////////////////\u000A// SYCL boiler plate\u000A//////////////////////////////////////////////////////////////////////////////\u000A\u000A#if FPGA_EMULATOR || FPGA_HARDWARE || FPGA_SIMULATOR\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000A//////////////////////////////////////////////////////////////////////////////\u000A// Kernel exception handler Just rethrows exceptions and terminates\u000A// \"gracefully\".\u000A//////////////////////////////////////////////////////////////////////////////\u000A\u000Astatic auto exception_handler = [](sycl::exception_list e_list) {\u000A  for (std::exception_ptr const &e : e_list) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A//////////////////////////////////////////////////////////////////////////////\u000A// prepare test pattern buffers\u000A//////////////////////////////////////////////////////////////////////////////\u000A\u000ATuplePadded16 testInput_host[ROUNDS][TESTLEN][TWOPOWsmall(_P_)][_N_][_S_];\u000ATuplePadded16 testOutput_host[ROUNDS][_G_ * OVERSIZE];\u000A\u000Aint cheat[ROUNDS][_G_ * OVERSIZE] = {}; // precompute correct answer\u000A\u000Aint main(/*int argc, char** argv*/) {\u000A\u000A  printf(\"B=%d\\nS=%d\\nP=%d\\nN=%d\\nG=%d\\nI=%d\\nO=%d\\nkeysize=%lu\\nvalsize=%\"\u000A         \"lu\\noverrun%d\\noversize%d\\n\",\u000A         _B_, _S_, _P_, _N_, _G_, _I_, _O_, sizeof(AggKey), sizeof(AggVal),\u000A         OVERRUN, OVERSIZE);\u000A\u000A  //\u000A  // basic parameter checks\u000A  //\u000A  MY_ASSERT(!((_N_ - 1) & _N_)); // must be a 2 power\u000A  MY_ASSERT(!((_G_ - 1) & _G_)); // must be a 2 power\u000A  MY_ASSERT((_S_ >= 1) && (_S_ <= 4));\u000A  MY_ASSERT(sizeof(TuplePadded16) == 16);\u000A  MY_ASSERT((_G_ * OVERSIZE) >= (_G_ + OVERRUN));\u000A  MY_ASSERT(!((TWOPOWsmall(_P_) - 1) &\u000A              (TWOPOWsmall(_P_)))); // TWOPOWsmall only cover small values\u000A\u000A#if FPGA_SIMULATOR\u000A  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\u000A#elif FPGA_HARDWARE\u000A  auto selector = sycl::ext::intel::fpga_selector_v;\u000A#elif FPGA_EMULATOR\u000A  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\u000A#else\u000A  auto selector = default_selector_v;\u000A#endif\u000A\u000A  queue q(selector, exception_handler);\u000A\u000A  {\u000A    // make sure the device supports USM device allocations\u000A    auto device = q.get_device();\u000A\u000A    std::cout << \"Running on device: \"\u000A              << device.get_info<info::device::name>().c_str() << std::endl;\u000A  }\u000A\u000A  //////////////////////\u000A  // Set up test input\u000A  //////////////////////\u000A\u000A  for (UINT r = 0; r < ROUNDS; r++) {\u000A    for (UINT i = 0; i < TESTLEN; i++) {\u000A      for (UINT str = 0; str < _S_; str++) {\u000A        for (UINT ppln = 0; ppln < _P_; ppln++) {\u000A          for (UINT tup = 0; tup < _N_; tup++) {\u000A            UINT dummy = rand();\u000A            testInput_host[r][i][ppln][tup][str].valid = true;\u000A            testInput_host[r][i][ppln][tup][str].val = dummy % 7;\u000A            testInput_host[r][i][ppln][tup][str].key = (dummy % (_G_ + OVERRUN))\u000A                                                       << 5;\u000A\u000A#if TIMERUN == 0\u000A            cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5] +=\u000A                testInput_host[r][i][ppln][tup][str].val;\u000A#else\u000A            {\u000A              AggKey key =\u000A                  ((unsigned(r ^ i ^ ppln ^ tup ^ str)) % (_G_ + OVERRUN)) << 5;\u000A              AggVal val = r * TESTLEN * _S_ * _N_ * TWOPOWsmall(_P_) +\u000A                           i * _S_ * _N_ * TWOPOWsmall(_P_) + ppln * _S_ * _N_ +\u000A                           tup * _S_ + str;\u000A\u000A              cheat[r][key >> 5] += val;\u000A            }\u000A#endif\u000A          }\u000A        }\u000A      }\u000A    }\u000A  }\u000A\u000A  //////////////////////\u000A  // Set up and prepare device memory\u000A  //////////////////////\u000A\u000A  TuplePadded16 *testInput_device = malloc_device<TuplePadded16>(\u000A      ROUNDS * TESTLEN * _N_ * TWOPOWsmall(_P_) * _S_, q);\u000A  TuplePadded16 *testOutput_device =\u000A      malloc_device<TuplePadded16>(ROUNDS * _G_ * OVERSIZE, q);\u000A\u000A  q.memcpy(testInput_device, testInput_host,\u000A           ROUNDS * TESTLEN * _N_ * TWOPOWsmall(_P_) * _S_ *\u000A               sizeof(TuplePadded16));\u000A  q.wait();\u000A\u000A  //\u000A  // Interesting stuff here. Think of it as drawing a streaming node\u000A  // graph in code\u000A  //\u000A  try {\u000A    // Source Stage: inject testInput\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class testInputSrcTask>([=]() {\u000A        [[intel::initiation_interval(1)]] for (UINT r = 0; r < ROUNDS; r++) {\u000A          for (UINT i = 0; i < TESTLEN; i++) {\u000A            for (UIDX str = 0; str < _S_; str++) {\u000A              TuplesBundle<_P_, _N_> bundle;\u000A              for (UINT ppln = 0; ppln < _P_; ppln++) {\u000A                for (UINT tup = 0; tup < _N_; tup++) {\u000A#if TIMERUN == 0\u000A                  // real data sources won't be fast enough in many cases\u000A                  TuplePadded16 tuple16 =\u000A                      testInput_device[r * TESTLEN * _S_ * _N_ *\u000A                                           TWOPOWsmall(_P_) +\u000A                                       i * _S_ * _N_ * TWOPOWsmall(_P_) +\u000A                                       ppln * _S_ * _N_ + tup * _S_ + str];\u000A                  bundle.tuples[ppln][tup].valid = true;\u000A                  bundle.tuples[ppln][tup].key = tuple16.key;\u000A                  bundle.tuples[ppln][tup].val = tuple16.val;\u000A#else\u000A                  // to generate input all full rate\u000A                  bundle.tuples[ppln][tup].valid = true;\u000A                  bundle.tuples[ppln][tup].key =\u000A                      ((unsigned(r ^ i ^ ppln ^ tup ^ str)) % (_G_ + OVERRUN))\u000A                      << 5;\u000A                  bundle.tuples[ppln][tup].val =\u000A                      r * TESTLEN * _S_ * _N_ * TWOPOWsmall(_P_) +\u000A                      i * _S_ * _N_ * TWOPOWsmall(_P_) + ppln * _S_ * _N_ +\u000A                      tup * _S_ + str;\u000A#endif\u000A                }\u000A              }\u000A              bundle.eof = (i == TESTLEN - 1);\u000A\u000A              // \"pipe\" is a type, not a variable.\u000A              switch (str) {\u000A              case 0: {\u000A                TestInputPipe0::write(bundle);\u000A                break;\u000A              }\u000A#if (_S_ > 1)\u000A              case 1: {\u000A                TestInputPipe1::write(bundle);\u000A                break;\u000A              }\u000A#endif\u000A#if (_S_ > 2)\u000A              case 2: {\u000A                TestInputPipe2::write(bundle);\u000A                break;\u000A              }\u000A#endif\u000A#if (_S_ > 3)\u000A              case 3: {\u000A                TestInputPipe3::write(bundle);\u000A                break;\u000A              }\u000A#endif\u000A              }\u000A            }\u000A          }\u000A        }\u000A      });\u000A    });\u000A\u000A    //\u000A    // first string of streaming stages: uniquify->map->aggregate\u000A    //\u000A\u000A    // Merge same-cycle, same-key tuples so keys are unique in each\u000A    // cycle (assumed by the mapper).\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MakeUniqueTask0>([=]() {\u000A        uniquifyStage<TestInputPipe0, UniqueTuplesPipe0, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A\u000A    // Maps unique keys to indices.  Keys that fails to map (after Gth\u000A    // unique key) is indicated in the mapped field. The\u000A    // map stage can be used in cascade mode where unmapped tuples in\u000A    // the first stage can flow into a second stage.\u000A    // stage to be mapped.\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MapKeyTask0>([=]() {\u000A        mapKey2IdxStage<UniqueTuplesPipe0, MappedTuplesPipe0A, _P_, _N_, _G_,\u000A                        0>();\u000A      });\u000A    });\u000A\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class TraiageMappingTask0>([=]() {\u000A        triageStage<MappedTuplesPipe0A, MappedTuplesPipe0B,\u000A                    UnmappableTuplesPipe0, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A\u000A    // aggregation tuples according key to idx mapping\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class AggregateTask0>([=]() {\u000A        aggregateStage<MappedTuplesPipe0B, CollectTuplesPipe0, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A\u000A    // We have to parameterize by S like this because a \"pipe\" is a\u000A    // type, not a variable or object.\u000A#if (_S_ > 1)\u000A    //\u000A    // second string\u000A    //\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MakeUniqueTask1>([=]() {\u000A        uniquifyStage<TestInputPipe1, UniqueTuplesPipe1, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MapKeyTask1>([=]() {\u000A        mapKey2IdxStage<UniqueTuplesPipe1, MappedTuplesPipe1A, _P_, _N_, _G_,\u000A                        0>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class TraiageMappingTask1>([=]() {\u000A        triageStage<MappedTuplesPipe1A, MappedTuplesPipe1B,\u000A                    UnmappableTuplesPipe1, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class AggregateTask1>([=]() {\u000A        aggregateStage<MappedTuplesPipe1B, CollectTuplesPipe1, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A#endif\u000A\u000A#if (_S_ > 2)\u000A    //\u000A    // third string\u000A    //\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MakeUniqueTask2>([=]() {\u000A        uniquifyStage<TestInputPipe2, UniqueTuplesPipe2, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MapKeyTask2>([=]() {\u000A        mapKey2IdxStage<UniqueTuplesPipe2, MappedTuplesPipe2A, _P_, _N_, _G_,\u000A                        0>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class TraiageMappingTask2>([=]() {\u000A        triageStage<MappedTuplesPipe2A, MappedTuplesPipe2B,\u000A                    UnmappableTuplesPipe2, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class AggregateTask2>([=]() {\u000A        aggregateStage<MappedTuplesPipe2B, CollectTuplesPipe2, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A#endif\u000A\u000A#if (_S_ > 3)\u000A    //\u000A    // fourth string\u000A    //\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MakeUniqueTask3>([=]() {\u000A        uniquifyStage<TestInputPipe3, UniqueTuplesPipe3, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MapKeyTask3>([=]() {\u000A        mapKey2IdxStage<UniqueTuplesPipe3, MappedTuplesPipe3A, _P_, _N_, _G_,\u000A                        0>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class TraiageMappingTask3>([=]() {\u000A        triageStage<MappedTuplesPipe3A, MappedTuplesPipe3B,\u000A                    UnmappableTuplesPipe3, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class AggregateTask3>([=]() {\u000A        aggregateStage<MappedTuplesPipe3B, CollectTuplesPipe3, _P_, _N_, _G_>();\u000A      });\u000A    });\u000A#endif\u000A\u000A    q.submit([&](handler &h) {\u000A      h.single_task<class MergeAndAggregateTask>([=]() {\u000A        mergeAggregateStage<CollectTuplesPipe0, CollectTuplesPipe1,\u000A                            CollectTuplesPipe2, CollectTuplesPipe3,\u000A                            UnmappableTuplesPipe0, UnmappableTuplesPipe1,\u000A                            UnmappableTuplesPipe2, UnmappableTuplesPipe3,\u000A                            ReadoutTuplePipe, _S_, _P_, _N_, _G_, OVERSIZE>();\u000A      });\u000A    });\u000A\u000A    // write to dram to communicate back to host\u000A    auto ev = q.submit([&](handler &h) {\u000A      h.single_task<class ReadoutTask>([=]() {\u000A        for (UINT r = 0; r < ROUNDS; r++) {\u000A          [[intel::initiation_interval(1)]]\u000A          //[[intel::disable_loop_pipelining]]\u000A          for (AggTblIdx grp = 0; grp < (_G_ * OVERSIZE); grp++) {\u000A            Tuple tuple = ReadoutTuplePipe::read();\u000A\u000A            {\u000A              TuplePadded16 tuple16;\u000A              tuple16.valid = tuple.valid;\u000A              tuple16.key = tuple.key;\u000A              tuple16.val = tuple.val;\u000A              testOutput_device[r * _G_ * OVERSIZE + grp] = tuple16;\u000A            }\u000A          }\u000A        }\u000A      });\u000A    });\u000A\u000A    ev.wait();\u000A  } catch (std::exception const &e) {\u000A    std::cerr << \"Exception!\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A  auto ev = q.memcpy(testOutput_host, testOutput_device,\u000A                     ROUNDS * _G_ * OVERSIZE * sizeof(TuplePadded16));\u000A  ev.wait();\u000A\u000A  {\u000A    BOOL correct = true;\u000A\u000A    for (UINT r = 0; r < ROUNDS; r++) {\u000A      TuplePadded16 canonical[_G_ * OVERSIZE] = {};\u000A      for (UIDX i = 0; i < (_G_ * OVERSIZE); i++) {\u000A        BOOL valid = testOutput_host[r][i].valid;\u000A        AggKey key = testOutput_host[r][i].key >> 5;\u000A        AggVal sum = testOutput_host[r][i].val;\u000A\u000A        // To support checking, key is randomly generated between 0 and\u000A        // G-1, times 32.  A cheatshet is computed at generation time.\u000A        MY_ASSERT(key < (_G_ * OVERSIZE));\u000A        AggVal answer = valid ? cheat[r][key] : 0;\u000A\u000A        if (valid) {\u000A          MY_ASSERT(!canonical[key].valid);\u000A          canonical[key] = testOutput_host[r][i];\u000A        }\u000A        MY_ASSERT((answer > 0) ? valid : true);\u000A        correct &= (answer == sum);\u000A      }\u000A\u000A      printf(\"ROUND %d:\\n\", r);\u000A      for (UIDX i = 0; i < (_G_ * OVERSIZE); i++) {\u000A        BOOL valid = canonical[i].valid;\u000A        AggKey key = canonical[i].key >> 5;\u000A        AggVal sum = canonical[i].val;\u000A        AggVal answer = valid ? cheat[r][key] : 0;\u000A\u000A        printf(\"(%d:%d) key=%d sum=%d answer=%d%s\\n\", i, valid, key, sum,\u000A               answer, (sum == answer) ? \"\" : \" mismatch\");\u000A      }\u000A    }\u000A    fflush(stdout);\u000A    MY_ASSERT(correct);\u000A  }\u000A\u000A  return 0;\u000A}\u000A"}, {"path":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/pipes.h", "name":"pipes.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/pipes.h", "content":"#ifndef PIPES_H\u000A#define PIPES_H\u000A\u000A#define DFLT_PIPE_DEPTH (16)\u000A\u000A#include <sycl/sycl.hpp>\u000Ausing namespace sycl;\u000A\u000A#include \"agg.h\"\u000A\u000Atemplate <int TNumPipeline, int TNumTuple> struct TuplesBundle {\u000A  Tuple tuples[TNumPipeline][TNumTuple];\u000A  BOOL eof;\u000A};\u000A\u000Atemplate <int TNumPipeline, int TNumTuple> struct MappedTuplesBundle {\u000A  Tuple tuples[TNumPipeline][TNumTuple];\u000A  BOOL mapped[TNumPipeline][TNumTuple];\u000A  AggTblIdx idx[TNumPipeline][TNumTuple]; // linear table idx\u000A  BOOL eof;\u000A};\u000A\u000A// pipes from input source (in main.cpp) to uniquify stage\u000Ausing TestInputPipe0 =\u000A    ext::intel::pipe<class pipe0_0, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000Ausing TestInputPipe1 =\u000A    ext::intel::pipe<class pipe0_1, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000Ausing TestInputPipe2 =\u000A    ext::intel::pipe<class pipe0_2, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000Ausing TestInputPipe3 =\u000A    ext::intel::pipe<class pipe0_3, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from uniquify stage to key mapping stage\u000Ausing UniqueTuplesPipe0 =\u000A    ext::intel::pipe<class pipe1_0, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UniqueTuplesPipe1 =\u000A    ext::intel::pipe<class pipe1_1, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UniqueTuplesPipe2 =\u000A    ext::intel::pipe<class pipe1_2, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UniqueTuplesPipe3 =\u000A    ext::intel::pipe<class pipe1_3, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from map stage to triage stage\u000Ausing MappedTuplesPipe0A =\u000A    ext::intel::pipe<class pipe2_0A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe1A =\u000A    ext::intel::pipe<class pipe2_1A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe2A =\u000A    ext::intel::pipe<class pipe2_2A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe3A =\u000A    ext::intel::pipe<class pipe2_3A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from triage stage to accumulate stage\u000Ausing MappedTuplesPipe0B =\u000A    ext::intel::pipe<class pipe2_0B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe1B =\u000A    ext::intel::pipe<class pipe2_1B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe2B =\u000A    ext::intel::pipe<class pipe2_2B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe3B =\u000A    ext::intel::pipe<class pipe2_3B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from triage stage to summation stage\u000Ausing UnmappableTuplesPipe0 =\u000A    ext::intel::pipe<class pipe2_0C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UnmappableTuplesPipe1 =\u000A    ext::intel::pipe<class pipe2_1C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UnmappableTuplesPipe2 =\u000A    ext::intel::pipe<class pipe2_2C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UnmappableTuplesPipe3 =\u000A    ext::intel::pipe<class pipe2_3C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from accumulate stage (final read out) to merge stage\u000Ausing CollectTuplesPipe0 = ext::intel::pipe<class pipe3_0, Tuple, _G_>;\u000Ausing CollectTuplesPipe1 = ext::intel::pipe<class pipe3_1, Tuple, _G_>;\u000Ausing CollectTuplesPipe2 = ext::intel::pipe<class pipe3_2, Tuple, _G_>;\u000Ausing CollectTuplesPipe3 = ext::intel::pipe<class pipe3_3, Tuple, _G_>;\u000A\u000Ausing ReadoutTuplePipe = ext::intel::pipe<class pipe6, Tuple, _G_>;\u000A\u000A#endif\u000A"}, {"path":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/stages.h", "name":"stages.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/stages.h", "content":"#ifndef STAGES_H\u000A#define STAGES_H\u000A\u000A#include <sycl/sycl.hpp>\u000Ausing namespace sycl;\u000A\u000A#include \"agg.h\"\u000A#include \"core.h\"\u000A#include \"debug.h\"\u000A#include \"pipes.h\"\u000A#include \"types.h\"\u000A\u000A// All streaming stages follows a common construction based on a main\u000A// ii=1 loops, in many case infinite. An iteration should start every\u000A// cycle, with the sequential loop body pipelined by the compiler to\u000A// overlap many iterations.  The tasks have no arguments.  Only input\u000A// and output are done through pipes.  Because pipes are types,\u000A// template is used to create the semblance of \"pipe arguments\".\u000A\u000A// create unique tuples\u000Atemplate <typename TTuplesInPipe, typename TTuplesOutPipe, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup>\u000Avoid uniquifyStage() {\u000A\u000A  [[intel::initiation_interval(1)]] while (1) {\u000A\u000A    TuplesBundle<TNumPipeline, TNumTuple> iBundle = TTuplesInPipe::read();\u000A\u000A    [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple>\u000A        oBundle = {}; // zero out idx!!\u000A\u000A#pragma unroll\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      collectTuples<TNumTuple, TNumGroup>(iBundle.tuples[ppln],\u000A                                          oBundle.tuples[ppln]);\u000A    }\u000A\u000A    oBundle.eof = iBundle.eof;\u000A\u000A    TTuplesOutPipe::write(oBundle);\u000A  }\u000A}\u000A\u000A// Translate key to idx for use in the aggregate stage. Multiple (M)\u000A// map stages can be used in cascade mode to map M*TNumGroup\u000A// groups. See main.cpp for example.\u000Atemplate <typename TTuplesInPipe, typename TTuplesOutPipe, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup, int TOffset>\u000Avoid mapKey2IdxStage() {\u000A\u000A  MAPPER_DECLARE(TNumPipeline, TNumTuple, TNumGroup, TOffset);\u000A\u000A  [[intel::initiation_interval(1)]] while (1) {\u000A\u000A    [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple>\u000A        iBundle = TTuplesInPipe::read();\u000A\u000A    [[intel::fpga_register]] // sanity check\u000A    MappedTuplesBundle<TNumPipeline, TNumTuple>\u000A        oBundle;\u000A\u000A#pragma unroll\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      // Seems redundant but passing in oBundle.idx and oBundle.mapped\u000A      // directly to map() confuses the compiler analysis somehow\u000A      [[intel::fpga_register]] AggTblIdx idxOut[TNumTuple];\u000A      [[intel::fpga_register]] BOOL mappedOut[TNumTuple] = {};\u000A\u000A      MAPPER_MAP(iBundle.eof, iBundle.tuples[ppln], iBundle.idx[ppln],\u000A                 iBundle.mapped[ppln], idxOut, mappedOut, ppln);\u000A\u000A      // prepare output bundle\u000A#pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        // set mapper results\u000A        oBundle.idx[ppln][tup] = idxOut[tup];\u000A        oBundle.mapped[ppln][tup] = mappedOut[tup];\u000A      }\u000A\u000A#pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        // copy tuples\u000A        oBundle.tuples[ppln][tup] = iBundle.tuples[ppln][tup];\u000A      }\u000A    }\u000A\u000A    oBundle.eof = iBundle.eof;\u000A    TTuplesOutPipe::write(oBundle);\u000A  }\u000A}\u000A\u000A// fork unmaapable tuples for special processing\u000Atemplate <typename TTuplesInPipe, typename TTuplesOutPipeMapped,\u000A          typename TTuplesOutPipeUnmapped, int TNumPipeline, int TNumTuple,\u000A          int TNumGroup>\u000Avoid triageStage() {\u000A  [[intel::initiation_interval(1)]] while (1) {\u000A    BOOL unmappable = false;\u000A    MappedTuplesBundle inBundle = TTuplesInPipe::read();\u000A    MappedTuplesBundle<TNumPipeline, TNumTuple> goodBundle = inBundle;\u000A    MappedTuplesBundle<TNumPipeline, TNumTuple> badBundle = inBundle;\u000A\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A\u000A        if (inBundle.tuples[ppln][tup].valid && (!inBundle.mapped[ppln][tup])) {\u000A          goodBundle.tuples[ppln][tup].valid = false;\u000A          badBundle.tuples[ppln][tup].valid = true;\u000A          unmappable = true;\u000A        } else {\u000A          badBundle.tuples[ppln][tup].valid = false;\u000A        }\u000A      }\u000A    }\u000A\u000A    goodBundle.eof = inBundle.eof;\u000A    badBundle.eof = inBundle.eof;\u000A    TTuplesOutPipeMapped::write(goodBundle);\u000A    if (unmappable || badBundle.eof) {\u000A      TTuplesOutPipeUnmapped::write(badBundle);\u000A    }\u000A  }\u000A}\u000A\u000A// Accumulate tuples until end-of-frame is received; afterwards; read\u000A// out table entries one-by-one to send to next stages\u000Atemplate <typename TTuplesInPipe, typename TTuplesOutPipe, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup>\u000Avoid aggregateStage() {\u000A\u000A  // This would be neater if aggregator can be done as a class, but we\u000A  // need to control banking of the accumulation table. Compiler won't\u000A  // accept directives in the aggregator class.  Ugly macros are used\u000A  // to hide the ugliness from here.\u000A\u000A  // accumulation table in TNumTuple banks, duplicated for each tuple lane\u000A  AGG_DECLARE(TNumPipeline, TNumTuple, TNumGroup);\u000A\u000A  [[intel::disable_loop_pipelining]] while (1) {\u000A\u000A    AGG_ZERO_TABLE();\u000A\u000A    BOOL done = false;\u000A    BOOL done_ = false;\u000A    BOOL done__ = false;\u000A\u000A    // main loop, iterate until end-of-frame arrives\u000A    [[intel::initiation_interval(1)]] while (!done) {\u000A      BOOL iValid = false;\u000A      [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple>\u000A          iBundle;\u000A\u000A      // go round 2 more times without fetching new bundle to finish\u000A      // deferred updates\u000A      done = done_;\u000A      done_ = done__;\u000A\u000A      if (!done__) {\u000A        iBundle = TTuplesInPipe::read(iValid);\u000A      }\u000A\u000A#pragma unroll\u000A      for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A#pragma unroll\u000A        for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A          iBundle.tuples[ppln][tup].valid &= iValid;\u000A        }\u000A        AGG_UPDATE(iBundle.tuples[ppln], iBundle.idx[ppln], ppln);\u000A      }\u000A\u000A      if (iValid) {\u000A        if (iBundle.eof) {\u000A          done__ = true;\u000A        }\u000A      }\u000A    }\u000A\u000A    // read back accumulated values and send forward\u000A    [[intel::disable_loop_pipelining]] for (UIDX grp = 0; grp < TNumGroup;\u000A                                            grp++) {\u000A      Tuple tuples[TNumPipeline] = {};\u000A      AGG_READ(grp, tuples);\u000A      [[intel::disable_loop_pipelining]] for (UIDX ppln = 0;\u000A                                              ppln < TNumPipeline; ppln++) {\u000A        TTuplesOutPipe::write(tuples[ppln]);\u000A      }\u000A    }\u000A  }\u000A}\u000A\u000Atemplate <int TNumGroup, int TOversize>\u000Avoid seqAccumulate(Tuple tuple, TuplePadded16 table[TNumGroup * TOversize]) {\u000A  BOOL found = 0;\u000A  if (tuple.valid) {\u000A    [[intel::disable_loop_pipelining]] for (AggTblIdx grp = 0;\u000A                                            grp < (TNumGroup * TOversize);\u000A                                            grp++) {\u000A      TuplePadded16 entry = table[grp];\u000A      if (entry.valid) {\u000A        if (tuple.key == entry.key) {\u000A          entry.val += tuple.val;\u000A          table[grp] = entry;\u000A          found = true;\u000A          break;\u000A        }\u000A      } else {\u000A        entry.valid = true;\u000A        entry.key = tuple.key;\u000A        entry.val = tuple.val;\u000A        table[grp] = entry;\u000A        found = true;\u000A        break;\u000A      }\u000A    }\u000A    MY_ASSERT(found);\u000A  }\u000A}\u000A\u000A// Merge readback from S strings of aggregation into 1 string. No need\u000A// to go fast. This happens offline, in between sessions.\u000Atemplate <typename TTuplesInPipe0Summary, typename TTuplesInPipe1Summary,\u000A          typename TTuplesInPipe2Summary, typename TTuplesInPipe3Summary,\u000A          typename TTuplesInPipe0Unmapped, typename TTuplesInPipe1Unmapped,\u000A          typename TTuplesInPipe2Unmapped, typename TTuplesInPipe3Unmapped,\u000A          typename TTuplesOutPipe, int TNumString, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup, int TOversize>\u000Avoid mergeAggregateStage() {\u000A  [[intel::fpga_memory(\"BLOCK_RAM\"), intel::singlepump, intel::simple_dual_port,\u000A    /*intel::max_replicates(1),intel::numbanks(1)*/\u000A  ]] TuplePadded16 table[TNumGroup * TOversize];\u000A\u000A  [[intel::disable_loop_pipelining]] while (1) {\u000A    [[intel::disable_loop_pipelining]] for (AggTblIdx grp = 0;\u000A                                            grp < (TNumGroup * TOversize);\u000A                                            grp++) {\u000A      table[grp] = {};\u000A    }\u000A\u000A    {\u000A      UIDX str = 0;\u000A      UIDX eofCnt = 0;\u000A      BOOL eof[TNumString] = {};\u000A\u000A      while (eofCnt != TNumString) {\u000A\u000A        if (!eof[str]) {\u000A          BOOL valid = false;\u000A          [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple>\u000A              bundle;\u000A\u000A          switch (str) {\u000A          case 0: {\u000A            bundle = TTuplesInPipe0Unmapped::read(valid);\u000A            break;\u000A          }\u000A#if (_S_ > 1)\u000A          case 1: {\u000A            bundle = TTuplesInPipe1Unmapped::read(valid);\u000A            break;\u000A          }\u000A#endif\u000A#if (_S_ > 2)\u000A          case 2: {\u000A            bundle = TTuplesInPipe2Unmapped::read(valid);\u000A            break;\u000A          }\u000A#endif\u000A#if (_S_ > 3)\u000A          case 3: {\u000A            bundle = TTuplesInPipe3Unmapped::read(valid);\u000A            break;\u000A          }\u000A#endif\u000A          }\u000A\u000A          if (valid) {\u000A            for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A              for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A                seqAccumulate<TNumGroup, TOversize>(bundle.tuples[ppln][tup],\u000A                                                    table);\u000A              }\u000A            }\u000A            if (bundle.eof) {\u000A              eofCnt++;\u000A              eof[str] = true;\u000A            }\u000A          }\u000A        }\u000A\u000A        str++;\u000A        str %= TNumString;\u000A      }\u000A    }\u000A\u000A    // expecting G readbacks per string\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      for (AggTblIdx grp = 0; grp < TNumGroup; grp++) {\u000A        for (UIDX str = 0; str < TNumString; str++) {\u000A          Tuple tuple = {};\u000A\u000A          switch (str) {\u000A          case 0: {\u000A            tuple = TTuplesInPipe0Summary::read();\u000A            break;\u000A          }\u000A#if (_S_ > 1)\u000A          case 1: {\u000A            tuple = TTuplesInPipe1Summary::read();\u000A            break;\u000A          }\u000A#endif\u000A#if (_S_ > 2)\u000A          case 2: {\u000A            tuple = TTuplesInPipe2Summary::read();\u000A            break;\u000A          }\u000A#endif\u000A#if (_S_ > 3)\u000A          case 3: {\u000A            tuple = TTuplesInPipe3Summary::read();\u000A            break;\u000A          }\u000A#endif\u000A          }\u000A\u000A          seqAccumulate<TNumGroup, TOversize>(tuple, table);\u000A        }\u000A      }\u000A    } // ppln\u000A\u000A    for (AggTblIdx grp = 0; grp < (TNumGroup * TOversize); grp++) {\u000A      TuplePadded16 tr = table[grp];\u000A      Tuple tw;\u000A      tw.valid = tr.valid;\u000A      tw.key = tr.key;\u000A      tw.val = tr.val;\u000A      TTuplesOutPipe::write(tw);\u000A    }\u000A  } // while(1)\u000A}\u000A\u000A#ifdef SHOW_DEPRECATED\u000A#include \"stages_.h\"\u000A#endif\u000A\u000A#endif\u000A"}, {"path":"/ofs_install/oneapi/2023.2/tbb/2021.10.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/ofs_install/oneapi/2023.2/tbb/2021.10.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}, {"path":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/types.h", "name":"types.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/jamesBenchmark/agg-hls/types.h", "content":"#ifndef TYPES_H\u000A#define TYPES_H\u000A\u000A//\u000A// standard stuff: redefine as necessary for HLS\u000A//\u000A\u000A#define BITSINBYTE (8)\u000A#define BYTEMASK ((1 << BITSINBYTE) - 1)\u000A#define LGBITSINBYTE (3)\u000A\u000Atypedef unsigned char UBYTE; // a byte\u000Atypedef bool BOOL;           // stand-in for Boolean\u000A\u000Atypedef unsigned short UIDX; // small index for HW loops: 64k is enough\u000Atypedef unsigned int UIDXL;  // large index for data loops\u000A\u000Atypedef unsigned long ULONG;   // 8-byte generic\u000Atypedef unsigned short USHORT; // 2-byte generic\u000Atypedef unsigned char UCHAR;   // 1-byte generic\u000A\u000Atypedef int INT;\u000Atypedef unsigned int UINT;\u000A\u000A#endif\u000A"}]