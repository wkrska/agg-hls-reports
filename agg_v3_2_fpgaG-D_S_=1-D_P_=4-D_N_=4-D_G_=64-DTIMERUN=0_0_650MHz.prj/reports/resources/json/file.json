[{"path":"/home/wkrska/Aggregation/agg-hls/agg.h", "name":"agg.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/agg-hls/agg.h", "content":"#ifndef AGG_H\u000A#define AGG_H\u000A\u000A#include \"debug.h\"\u000A#include \"types.h\"\u000A#ifdef __INTELFPGA_COMPILER__ \u000A#include \"HLS/ac_int.h\" \u000A#else \u000A#include \"ref/ac_int.h\" \u000A#endif\u000A\u000A#define _B_                                                                    \\\u000A  (8) // Number of tuples received/emitted per cycle on the data bus\u000A      // (i.e., the line rate) This isn't used by this project (just\u000A      // reading test input from DRAM\u000A\u000A#ifndef _S_\u000A#define _S_ (1) // Number of computational cores (the scaling factor)\u000A#endif\u000A\u000A#ifndef _P_\u000A#define _P_ (4) // Like S,except these cores are lockstepped\u000A#endif\u000A\u000A#ifndef _N_\u000A#define _N_ (4) // Input width of each computational core. We choose N = 4.\u000A#endif\u000A\u000A#ifndef _G_\u000A#define _G_                                                                    \\\u000A  (64) // Number of aggregation groups the computational core is configured for\u000A       // (4 to 64)\u000A#endif\u000A\u000A#define _I_                                                                    \\\u000A  ((_N_) * (_S_) *                                                             \\\u000A   (_P_)) // Total number of input tuples processed in each cycle = SxN\u000A\u000A#define _O_                                                                    \\\u000A  ((_S_) * (_P_) *                                                             \\\u000A   (_G_)) // Total Total number of tuples created by local aggregation = SxG\u000A\u000A// For ease of use\u000A#define DYN_OP (0) // Dynamically choose operation\u000A#define AVG_OP (1) // Includes add and count implicitly\u000A#define MIN_OP (2)\u000A#define MAX_OP (3)\u000A\u000Atypedef unsigned int AggKey;\u000Atypedef unsigned int AggValVal;\u000Atypedef unsigned int AggValCnt;\u000Astruct AggVal {\u000A  AggValVal val;\u000A  AggValCnt cnt;\u000A  #ifdef SHOW_TUPLE_ID\u000A  unsigned int id;\u000A  #endif\u000A};\u000A\u000Atypedef ac_int<3,false> int3_t; // unsigned 3 bit integer for select\u000A\u000Astruct Tuple {\u000A  BOOL valid;\u000A  AggKey key;\u000A  AggVal val;\u000A};\u000A\u000A//\u000A// Tuple padded to 16-bytes\u000A//\u000A\u000Astruct TuplePadded16 {\u000A  UINT valid;\u000A  AggKey key;\u000A  AggVal val;\u000A};\u000A\u000A// a cam table will translate a key\u000A// to its table location\u000Atypedef unsigned short AggTblIdx;\u000A\u000A#endif"}, {"path":"/home/wkrska/Aggregation/agg-hls/core.h", "name":"core.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/agg-hls/core.h", "content":"// Core functions implementing a stream key-value aggregator as\u000A// described in \"FPGA for Aggregate Processing: The Good, The Bad, and\u000A// The Ugly\".\u000A\u000A#ifndef CORE_H\u000A#define CORE_H\u000A\u000A#include <cstdio>\u000A#include <cstdlib>\u000A#ifndef CXXONLY\u000A#include <sycl/sycl.hpp>\u000A#endif\u000A\u000A#include \"agg.h\"\u000A#include \"debug.h\"\u000A#include \"types.h\"\u000A#include <functional>\u000A\u000A// The following is used by a hack to work around a compiler issue\u000A// until next release. 1D array declared in structs has to be declared\u000A// as 2D to map to registers.\u000A#define ONE (1)\u000A#define ZERO (0)\u000A\u000A// Takes in TNumTuple KV pairs and returns up to TNumTuple KV\u000A// pairs. Input pairs with common keys are combined into one by\u000A// summing their values.  Absorbed positions are marked invalid.\u000Atemplate <class AggFunc, int TNumTuple, int TNumGroup>\u000Avoid collectTuples(\u000A  // input\u000A  int3_t AggFuncSelect,\u000A  Tuple in[TNumTuple],\u000A  // output\u000A  Tuple uniq[TNumTuple]) {\u000A\u000A  // initialize default\u000A  #pragma unroll\u000A  for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A    AggFunc::init(uniq[tup].val, AggFuncSelect); // Initialize agg values\u000A    uniq[tup].valid = in[tup].valid;\u000A    uniq[tup].key = in[tup].key;\u000A  }\u000A  \u000A  // N^2 / 2 comparisons to collect common key pairs\u000A  #pragma unroll\u000A  for (UIDX i = 0; i < TNumTuple; i++) {\u000A    uniq[i].val = in[i].val;\u000A    #pragma unroll\u000A    for (UIDX j = i + 1; j < TNumTuple; j++) {\u000A      if (in[i].valid && in[j].valid && (in[i].key == in[j].key)) {\u000A        uniq[j].valid = false;    // invalid absorbed position\u000A        AggFunc::run(uniq[i].val, in[j].val, AggFuncSelect);\u000A      }\u000A    }\u000A  }\u000A}\u000A\u000A// Translate TNumTuples to their allocated table locations.  Allocate\u000A// new location when seeing a key for the first time. This implements\u000A// a systolic array with O(G) delay but fixed FMAX independent of\u000A// G.\u000A\u000A// There is a compiler quirkiness having to do with adding banking\u000A// directives to \"struct with arrays\" and/or \"array of structs\". The\u000A// table array has to be declared flat, outside of a struct/class. To\u000A// be revisited in the future.\u000A\u000A// The macros below is a clumsy way of making things a little easier\u000A// to use since we can't make a proper class.\u000A#define MAPPER_DECLARE(P, N, G, O)                                             \\\u000A  [[intel::fpga_register]] AggKey __camKey[(P)][(G)] = {};                     \\\u000A  [[intel::fpga_register]] BOOL __camValid[(P)][(G)] = {};                     \\\u000A  CoreKeyMapper<(P), (N), (G), (O)> __mapper;\u000A\u000A#define MAPPER_MAP(flush, it, ii, im, oi, om, p)                               \\\u000A  __mapper.map((flush), (it), (ii), (im), (oi), (om), __camKey, __camValid,    \\\u000A               (p));\u000A\u000Atemplate <int TNumPipeline, int TNumTuple, int TNumGroup, int TOffset>\u000Astruct CoreKeyMapper {\u000A  //\u000A  // CAM map table array to be implemented as registers\u000A  //\u000A\u000A  // map key to index; allocate on the fly; deep pipelining streaming\u000A  // CAM lookup\u000A  void map(\u000A    // input\u000A    BOOL flush,\u000A    Tuple uniqIn[TNumTuple],    // cannot have duplicate keys\u000A    AggTblIdx idxIn[TNumTuple], // from upstream translated linear index for\u000A                                // valid tuples\u000A    BOOL mappedIn[TNumTuple],\u000A\u000A    // output\u000A    AggTblIdx\u000A        idxOut[TNumTuple], // output translated linear index for valid tuples\u000A    BOOL mappedOut[TNumTuple],\u000A\u000A    // STATE\u000A    AggKey camKey[TNumPipeline][TNumGroup],\u000A    BOOL camValid[TNumPipeline][TNumGroup],\u000A\u000A    // STATE idx\u000A    UIDX ppln) {\u000A    #pragma unroll\u000A    for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A      // in cascade mode, transfer already mapped indices\u000A      idxOut[tup] = idxIn[tup];\u000A      mappedOut[tup] = mappedIn[tup];\u000A    }\u000A\u000A    // CAM populated from 0 to G-1\u000A    #pragma unroll\u000A    for (UIDX grp = 0; grp < TNumGroup; grp++) {\u000A      // this unrolls into very deep cascaded stages; CAM lookup is\u000A      // serialized and pipelined across by the lookup stream.\u000A      if (camValid[ppln][grp]) {\u000A        // on a valid location, try mapping\u000A      #pragma unroll\u000A        for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A          if (uniqIn[tup].valid && camValid[ppln][grp] &&\u000A              (uniqIn[tup].key == camKey[ppln][grp])) {\u000A            mappedOut[tup] = true;\u000A            idxOut[tup] = grp + TOffset * TNumGroup;\u000A          }\u000A        }\u000A      } else {\u000A        #pragma unroll\u000A        for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A          if (uniqIn[tup].valid && !mappedOut[tup]) {\u000A            // if still not mapped after exhausting previous keys;\u000A            // allocate a new one\u000A            camValid[ppln][grp] = true;\u000A            camKey[ppln][grp] = uniqIn[tup].key;\u000A            mappedOut[tup] = true;\u000A            idxOut[tup] = grp + TOffset * TNumGroup;\u000A            break; // go to next location for remaining unmapped\u000A                   // tuples\u000A          }\u000A        }\u000A      }\u000A      if (flush) {\u000A        camValid[ppln][grp] = false;\u000A        // camKey[ppln][grp] = uniqIn[tup].key;\u000A      }\u000A    }\u000A    return;\u000A  }\u000A};\u000A\u000A// Aggregate into linearly indexed table.  Unlike V0, this version\u000A// uses N-copies of 1R1W parallel tables to accumulate separately for\u000A// each tuple lane. These N tables made from BRAM are much\u000A// cheaper/faster than using only 1 table (NR+NW) made from registers.\u000A\u000A// There is a compiler quirkiness having to do with adding banking\u000A// directives to \"struct with arrays\" and/or \"array of structs\". The\u000A// table array has to be declared flat, outside of a struct/class. To\u000A// be revisited in the future.\u000A\u000A// The macros below is a clumsy way of making things a little easier\u000A// to use since we can't make a proper class.\u000A#define TWOPOWsmall(N)                                                         \\\u000A  (((N) <= 2)                                                                  \\\u000A       ? (N)                                                                   \\\u000A       : (((N) <= 4)                                                           \\\u000A              ? 4                                                              \\\u000A              : (((N) <= 8)                                                    \\\u000A                     ? 8                                                       \\\u000A                     : (((N) <= 16)                                            \\\u000A                            ? 16                                               \\\u000A                            : (((N) <= 32) ? 32                                \\\u000A                                           : (((N) <= 64) ? 64 : (N)))))))\u000A\u000A#define AGG_DECLARE(AggFunc, P, N, G)                                                \\\u000A  [[intel::fpga_memory(\"BLOCK_RAM\"), intel::singlepump,                        \\\u000A    intel::simple_dual_port /*, intel::bankwidth(sizeof(TuplePadded16)),       \\\u000A                              intel::max_replicates(1),                        \\\u000A                              intel::numbanks((N)*TWOPOWsmall(P))*/            \\\u000A  ]] TuplePadded16 __table[(G)][TWOPOWsmall(P)][(N)];                          \\\u000A  [[intel::fpga_register]] TuplePadded16 __deferred[(P)][2][(N)] = {};         \\\u000A  [[intel::fpga_register]] AggTblIdx __deferredIdx[(P)][2][(N)] = {};          \\\u000A  [[intel::fpga_register]] CoreAggregator<AggFunc, (P), (N), (G)> __agg;\u000A\u000A#define AGG_INIT_TABLE(aggFuncSelect) __agg.init(aggFuncSelect, __table)\u000A\u000A#define AGG_UPDATE(s, t, i, p)                                                    \\\u000A  __agg.update((s), (t), (i), __table, __deferred, __deferredIdx, (p))\u000A\u000A#define AGG_READ(aggFuncSelect, idx, tups) __agg.read(aggFuncSelect, idx, tups, __table)\u000A\u000Atemplate <class AggFunc, int TNumPipeline, int TNumTuple, int TNumGroup>\u000Astruct CoreAggregator {\u000A\u000A  // states has to live outside unfortunately.\u000A\u000A  // BRAM array can't be zero by \"={}\";\u000A  void init(\u000A    // input\u000A    int3_t AggFuncSelect,\u000A    // STATE\u000A    TuplePadded16 table[TNumGroup][TWOPOWsmall(TNumPipeline)][TNumTuple]) {\u000A\u000A    MY_ASSERT(\u000A      !((TWOPOWsmall(TNumPipeline) - 1) &\u000A        (TWOPOWsmall(TNumPipeline)))); // TWOPOWsmall only cover small values\u000A\u000A    [[intel::disable_loop_pipelining]] for (UIDX grp = 0; grp < TNumGroup; grp++) {\u000A      #pragma unroll\u000A      for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A        #pragma unroll\u000A        for (UIDX tub = 0; tub < TNumTuple; tub++) {\u000A          table[grp][ppln][tub] = {};\u000A          AggFunc::init(table[grp][ppln][tub].val, AggFuncSelect);\u000A        }\u000A      }\u000A    }\u000A  }\u000A\u000A  void update(\u000A    // input\u000A    int3_t AggFuncSelect,\u000A    Tuple in[TNumTuple],      // unique key tuples\u000A    AggTblIdx idx[TNumTuple], // linear idx from mapper stage\u000A\u000A    // STATE passed in by reference\u000A    TuplePadded16 table[TNumGroup][TWOPOWsmall(TNumPipeline)][TNumTuple],\u000A    TuplePadded16 deferred[TWOPOWsmall(TNumPipeline)][2][TNumTuple],\u000A    AggTblIdx deferredIdx[TWOPOWsmall(TNumPipeline)][2][TNumTuple],\u000A\u000A    // STATE idx\u000A    UIDX ppln) {\u000A\u000A    TuplePadded16 update[TNumTuple] = {};\u000A\u000A    {\u000A      BOOL frwd[TNumTuple] = {};\u000A      AggVal frwdVal[TNumTuple];\u000A\u000A      //\u000A\u000A      // find forwarding from memoized updates of not yet written\u000A      // (works within lane)\u000A      #pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        if ((idx[tup] == deferredIdx[ppln][0][tup]) &&\u000A            deferred[ppln][0][tup].valid) {\u000A          // distance 1 RAW\u000A          MY_ASSERT(in[tup].valid ? in[tup].key == deferred[ppln][0][tup].key\u000A                                  : true);\u000A          frwd[tup] = true;\u000A          frwdVal[tup] = deferred[ppln][0][tup].val;\u000A        } else if ((idx[tup] == deferredIdx[ppln][1][tup]) &&\u000A                   deferred[ppln][1][tup].valid) {\u000A          // distance 2 RAW\u000A          MY_ASSERT(in[tup].valid ? in[tup].key == deferred[ppln][1][tup].key\u000A                                  : true);\u000A          frwd[tup] = true;\u000A          frwdVal[tup] = deferred[ppln][1][tup].val;\u000A        }\u000A      }\u000A\u000A      // compute new table entry value\u000A      #pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        TuplePadded16 temp = table[idx[tup]][ppln][tup];\u000A        update[tup].valid = in[tup].valid;\u000A        update[tup].key = in[tup].key; // overwrite okay\u000A        update[tup].val = in[tup].val;\u000A        AggFunc::run(update[tup].val, ((frwd[tup] ? frwdVal[tup] : temp.val)), AggFuncSelect);\u000A      }\u000A    }\u000A\u000A    #pragma unroll\u000A    for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A      // write deferred updates from 2 iters ago\u000A      if (deferred[ppln][1][tup].valid) {\u000A        table[deferredIdx[ppln][1][tup]][ppln][tup] = deferred[ppln][1][tup];\u000A      }\u000A      // shift\u000A      deferred[ppln][1][tup] = deferred[ppln][0][tup];\u000A      deferredIdx[ppln][1][tup] = deferredIdx[ppln][0][tup];\u000A    }\u000A\u000A    #pragma unroll\u000A    for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A      // record deferred updates to next round\u000A      deferred[ppln][0][tup] = update[tup];\u000A      deferredIdx[ppln][0][tup] = idx[tup];\u000A    }\u000A  }\u000A\u000A  // Reading back when finished accumulating\u000A  void read(\u000A      // input\u000A      int3_t AggFuncSelect,\u000A      AggTblIdx idx,\u000A\u000A      // output\u000A      Tuple tuples[TNumPipeline],\u000A\u000A      // STATE\u000A      TuplePadded16 table[TNumGroup][TWOPOWsmall(TNumPipeline)][TNumTuple]) {\u000A    // sum across banks to compute total\u000A    #pragma unroll\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      AggFunc::init(tuples[ppln].val, AggFuncSelect); // Initialize tuples val\u000A      #pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        TuplePadded16 temp = table[idx][ppln][tup];\u000A        if (temp.valid) {\u000A          tuples[ppln].valid = true;\u000A          tuples[ppln].key = temp.key; // overwrite okay\u000A          AggFunc::run(tuples[ppln].val, temp.val, AggFuncSelect);\u000A        }\u000A      }\u000A    }\u000A  }\u000A};\u000A\u000A#ifdef SHOW_DEPRECATED\u000A#include \"core_.h\"\u000A#endif\u000A\u000A#endif\u000A"}, {"path":"/home/wkrska/Aggregation/agg-hls/debug.h", "name":"debug.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/agg-hls/debug.h", "content":"#ifndef DEBUG_H\u000A#define DEBUG_H\u000A\u000A#include <cassert>\u000A\u000A#if NO_MY_ASSERT\u000A#define MY_ASSERT(a)                                                           \\\u000A  {}\u000A#else\u000A#define MY_ASSERT(a) (assert(a))\u000A#endif\u000A\u000A// #define SHOW_TUPLE_ID // Assigns a unique id to each bundle for debugging purposes\u000A\u000A// #define SHOW_DEPRECATED\u000A\u000A#endif\u000A"}, {"path":"/home/wkrska/Aggregation/agg-hls/main.cpp", "name":"main.cpp", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/agg-hls/main.cpp", "content":"// SETUP TEST CONDITION\u000A#if 1\u000A  #define ROUNDS (8)        // number of rounds, reset in between\u000A  #define TESTLEN (1 << 16) // number TESTLEN*S*P*N tuples per round\u000A  #define OVERRUN (3)       // number of distinct keys to verflow G by; G is the number of\u000A                            // distinct keys supported in fast path; overflow goes to a slow\u000A                            // path to aggregate\u000A  #define OVERSIZE (2)      // oversize table for OVERSIZE*G results\u000A#elif 0\u000A  #define ROUNDS (8)\u000A  #define TESTLEN (1 << 16)\u000A  #define OVERRUN (0) // no overflow direct test\u000A  #define OVERSIZE (1)\u000A#else\u000A  #define ROUNDS (3) // small setup for debug\u000A  #define TESTLEN (1<<2)\u000A  #define OVERRUN (0)\u000A  #define OVERSIZE (1)\u000A#endif\u000A\u000A#ifndef AGG_OP\u000A  #define AGG_OP (0)\u000A#endif\u000A\u000A#if TIMERUN\u000A  #include <sys/time.h>\u000A#endif\u000A\u000A#include <array>\u000A#include <cstdio>\u000A#include <cstdlib>\u000A#include <iostream>\u000A#include <sycl/sycl.hpp>\u000Ausing namespace sycl;\u000A\u000A#include \"agg.h\"\u000A#include \"core.h\"\u000A#include \"debug.h\"\u000A#include \"pipes.h\"\u000A#include \"stages.h\"\u000A#include \"types.h\"\u000A\u000A//////////////////////////////////////////////////////////////////////////////\u000A// SYCL boiler plate\u000A//////////////////////////////////////////////////////////////////////////////\u000A\u000A#if FPGA_EMULATOR || FPGA_HARDWARE || FPGA_SIMULATOR\u000A  #include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000A//////////////////////////////////////////////////////////////////////////////\u000A// Kernel exception handler Just rethrows exceptions and terminates\u000A// \"gracefully\".\u000A//////////////////////////////////////////////////////////////////////////////\u000A\u000Astatic auto exception_handler = [](sycl::exception_list e_list)\u000A{\u000A  for (std::exception_ptr const &e : e_list)\u000A  {\u000A    try\u000A    {\u000A      std::rethrow_exception(e);\u000A    }\u000A    catch (std::exception const &e)\u000A    {\u000A      #if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A      #endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A//////////////////////////////////////////////////////////////////////////////\u000A// prepare test pattern buffers\u000A//////////////////////////////////////////////////////////////////////////////\u000A\u000ATuplePadded16 testInput_host[ROUNDS][TESTLEN][TWOPOWsmall(_P_)][_N_][_S_];\u000ATuplePadded16 testOutput_host[ROUNDS][_G_ * OVERSIZE];\u000A\u000Aunsigned int cheat[ROUNDS][_G_ * OVERSIZE] = {}; // precompute correct answer\u000A\u000Aint main(/*int argc, char** argv*/)\u000A{\u000A  printf(\"B=%d\\nS=%d\\nP=%d\\nN=%d\\nG=%d\\nI=%d\\nO=%d\\noverrun%d\\noversize%d\\n\",\u000A         _B_, _S_, _P_, _N_, _G_, _I_, _O_,\u000A         OVERRUN, OVERSIZE);\u000A  \u000A  //\u000A  // basic parameter checks\u000A  //\u000A  MY_ASSERT(!((_N_ - 1) & _N_)); // must be a 2 power\u000A  MY_ASSERT(!((_G_ - 1) & _G_)); // must be a 2 power\u000A  MY_ASSERT((_S_ >= 1) && (_S_ <= 4));\u000A  #ifndef SHOW_TUPLE_ID\u000A  MY_ASSERT(sizeof(TuplePadded16) == 16);\u000A  #endif\u000A  MY_ASSERT((_G_ * OVERSIZE) >= (_G_ + OVERRUN));\u000A  MY_ASSERT(!((TWOPOWsmall(_P_) - 1) &\u000A              (TWOPOWsmall(_P_)))); // TWOPOWsmall only cover small values\u000A\u000A#if FPGA_SIMULATOR\u000A  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\u000A#elif FPGA_HARDWARE\u000A  auto selector = sycl::ext::intel::fpga_selector_v;\u000A#elif FPGA_EMULATOR\u000A  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\u000A#else\u000A  auto selector = default_selector_v;\u000A#endif\u000A\u000A  queue q(selector, exception_handler);\u000A\u000A  {\u000A    // make sure the device supports USM device allocations\u000A    auto device = q.get_device();\u000A\u000A    std::cout << \"Running on device: \"\u000A              << device.get_info<info::device::name>().c_str() << std::endl;\u000A  }\u000A\u000A  //////////////////////\u000A  // Set up Aggregation function\u000A  //////////////////////\u000A\u000A  // Just for the purposes of our testing,\u000A  // the user can define any aggregation function as long as it takes these inputs\u000A  struct AggFunc {\u000A    static void run(AggVal &inout, AggVal &in, int3_t agg_op) {\u000A      \u000A      #if (AGG_OP == DYN_OP) // if DYNAMIC Aggregation\u000A        // Precompute sum, min, max\u000A        AggValVal t_sum = inout.val + in.val;\u000A        AggValVal t_min = (inout.val < in.val) ? inout.val : in.val;\u000A        AggValVal t_max = (inout.val > in.val) ? inout.val : in.val;\u000A\u000A        // Mux between outputs based on operation\u000A        if (agg_op == (int3_t) AVG_OP) {\u000A          inout.val = t_sum;\u000A        } else if (agg_op == (int3_t) MIN_OP) {\u000A          inout.val = t_min;\u000A        } else if (agg_op == (int3_t) MAX_OP) {\u000A          inout.val = t_max;\u000A        } \u000A      #elif (AGG_OP == AVG_OP) // if only sum/average/count\u000A        inout.val = inout.val + in.val;\u000A      #elif (AGG_OP == MIN_OP) // if only min\u000A        inout.val = (inout.val < in.val) ? inout.val : in.val;\u000A      #elif (AGG_OP == MAX_OP) // if only max\u000A        inout.val = (inout.val > in.val) ? inout.val : in.val;\u000A      #else // Invalid case\u000A        inout.val = 0;\u000A      #endif\u000A\u000A      // Always compute Count\u000A      inout.cnt += in.cnt;\u000A\u000A      // If debugging and using tuple ID\u000A      #ifdef SHOW_TUPLE_ID\u000A      // figure out size of in id\u000A      unsigned int temp_id = in.id;\u000A      while (temp_id > 0) {\u000A        temp_id /= 100;\u000A        inout.id *= 100;\u000A      }\u000A      inout.id += in.id; // concat values\u000A      #endif\u000A    }\u000A\u000A    static void init(AggVal &val, int3_t agg_op) {\u000A      // User Defined initializer for intermediate and output AggVals\u000A      if (agg_op != (int3_t) MIN_OP) // set the value to 0 iff not MIN operation\u000A        val.val = 0;\u000A      else \u000A        val.val = (AggValVal) ~0;\u000A\u000A      // Always set count to 0;\u000A      val.cnt = 0;\u000A\u000A      // If debugging and using tuple ID\u000A      #ifdef SHOW_TUPLE_ID\u000A      val.id = 0;\u000A      #endif\u000A    }\u000A  };\u000A\u000A  // int agg_op = (argc > 1 && atoi(argv[argc-1]) != -1) ? atoi(argv[argc-1]) : AGG_OP;\u000A  int3_t agg_ops[ROUNDS+1] = {};\u000A\u000A  //////////////////////\u000A  // Set up test input and cheat values\u000A  //////////////////////\u000A  #ifdef SHOW_TUPLE_ID\u000A  unsigned int id = 0;\u000A  #endif\u000A  for (UINT r = 0; r < ROUNDS; r++) {\u000A    // Set agg_ops\u000A    if (AGG_OP == 0)\u000A      agg_ops[r] = (int3_t) r%3 + 1;\u000A    else\u000A      agg_ops[r] = (int3_t) AGG_OP;\u000A\u000A    // Special cheat init for MIN only\u000A    if (agg_ops[r] == MIN_OP) {\u000A      for (UINT tmp = 0; tmp < _G_ * OVERSIZE; tmp++) {\u000A        cheat[r][tmp] = (AggValVal) ~0;\u000A      }\u000A    }\u000A\u000A    for (UINT i = 0; i < TESTLEN; i++) {\u000A      for (UINT str = 0; str < _S_; str++) {\u000A        for (UINT ppln = 0; ppln < _P_; ppln++) {\u000A          for (UINT tup = 0; tup < _N_; tup++) {\u000A            UINT dummy = rand();\u000A            // UINT dummy = r+i+str+ppln+tup;\u000A            testInput_host[r][i][ppln][tup][str].valid = true;\u000A            testInput_host[r][i][ppln][tup][str].key = (dummy % (_G_ + OVERRUN))\u000A                                                       << 5;\u000A            // testInput_host[r][i][ppln][tup][str].val = AggVal(dummy % 7, 1);\u000A            testInput_host[r][i][ppln][tup][str].val.val = dummy % 7;\u000A            testInput_host[r][i][ppln][tup][str].val.cnt = 1;\u000A\u000A            #ifdef SHOW_TUPLE_ID\u000A            testInput_host[r][i][ppln][tup][str].val.id = ++id;\u000A            #endif\u000A\u000A            int agg_op = (int) agg_ops[r];\u000A            #if TIMERUN == 0\u000A              if (agg_op == AVG_OP) {\u000A                cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5] +=\u000A                    testInput_host[r][i][ppln][tup][str].val.val;\u000A              } else if (agg_op == MIN_OP) {\u000A                cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5] =\u000A                    (cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5] < testInput_host[r][i][ppln][tup][str].val.val)\u000A                        ? cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5]\u000A                        : testInput_host[r][i][ppln][tup][str].val.val;\u000A              } else if (agg_op == MAX_OP) {\u000A                cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5] =\u000A                    (cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5] > testInput_host[r][i][ppln][tup][str].val.val)\u000A                        ? cheat[r][testInput_host[r][i][ppln][tup][str].key >> 5]\u000A                        : testInput_host[r][i][ppln][tup][str].val.val;\u000A              }\u000A            #else\u000A              AggKey key =\u000A                  ((unsigned(r ^ i ^ ppln ^ tup ^ str)) % (_G_ + OVERRUN)) << 5;\u000A              // AggVal val = AggVal(r*TESTLEN*_S_*_N_*TWOPOWsmall(_P_) + i*_S_*_N_*TWOPOWsmall(_P_) + ppln*_S_*_N_ + tup*_S_ + str, 1);\u000A              AggVal val; val.val = r*TESTLEN*_S_*_N_*TWOPOWsmall(_P_) + i*_S_*_N_*TWOPOWsmall(_P_) + ppln*_S_*_N_ + tup*_S_ + str;\u000A                          val.cnt = 1;\u000A              if (agg_op == AVG_OP) {\u000A                cheat[r][key >> 5] += val.val;\u000A              } else if (agg_op == MIN_OP) {\u000A                cheat[r][key >> 5] = (cheat[r][key >> 5] < val.val) ? cheat[r][key >> 5] : val.val;\u000A              } else if (agg_op == MAX_OP) {\u000A                cheat[r][key >> 5] = (cheat[r][key >> 5] > val.val) ? cheat[r][key >> 5] : val.val;\u000A              }\u000A            #endif\u000A          }\u000A        }\u000A      }\u000A    }\u000A  }\u000A\u000A  //////////////////////\u000A  // Set up and prepare device memory\u000A  //////////////////////\u000A\u000A  TuplePadded16 *testInput_device = malloc_device<TuplePadded16>(\u000A      ROUNDS * TESTLEN * _N_ * TWOPOWsmall(_P_) * _S_, q);\u000A  TuplePadded16 *testOutput_device =\u000A      malloc_device<TuplePadded16>(ROUNDS * _G_ * OVERSIZE, q);\u000A\u000A  q.memcpy(testInput_device, testInput_host,\u000A           ROUNDS * TESTLEN * _N_ * TWOPOWsmall(_P_) * _S_ *\u000A               sizeof(TuplePadded16));\u000A  q.wait();\u000A\u000A  //////////////////////\u000A  // For timing the run, excludes input generation\u000A  //////////////////////\u000A  #if TIMERUN\u000A    struct timeval start, end;\u000A    // start timer.\u000A    gettimeofday(&start, NULL);\u000A  #endif\u000A\u000A  //\u000A  // Interesting stuff here. Think of it as drawing a streaming node\u000A  // graph in code\u000A  //\u000A  try\u000A  {\u000A    // Source Stage: inject testInput\u000A    q.submit([&](handler &h) { h.single_task<class testInputSrcTask>([=]() {\u000A        [[intel::initiation_interval(1)]] for (UINT r = 0; r < ROUNDS; r++) {\u000A          for (UINT i = 0; i < TESTLEN; i++) {\u000A            for (UIDX str = 0; str < _S_; str++) {\u000A              TuplesBundle<_P_, _N_> bundle;\u000A              for (UINT ppln = 0; ppln < _P_; ppln++) {\u000A                for (UINT tup = 0; tup < _N_; tup++) {\u000A                  #if TIMERUN == 0\u000A                  // real data sources won't be fast enough in many cases\u000A                  TuplePadded16 tuple16 =\u000A                      testInput_device[r * TESTLEN * _S_ * _N_ *\u000A                                      TWOPOWsmall(_P_) +\u000A                                      i * _S_ * _N_ * TWOPOWsmall(_P_) +\u000A                                      ppln * _S_ * _N_ + tup * _S_ + str];\u000A                  bundle.tuples[ppln][tup].valid = true;\u000A                  bundle.tuples[ppln][tup].key = tuple16.key;\u000A                  bundle.tuples[ppln][tup].val = tuple16.val;\u000A                  #else\u000A                  // to generate input all full rate\u000A                  bundle.tuples[ppln][tup].valid = true;\u000A                  bundle.tuples[ppln][tup].key = ((unsigned(r ^ i ^ ppln ^ tup ^ str)) % (_G_ + OVERRUN)) << 5;\u000A                  bundle.tuples[ppln][tup].val.val = r*TESTLEN*_S_*_N_* TWOPOWsmall(_P_) + i*_S_*_N_*TWOPOWsmall(_P_) + ppln*_S_*_N_ + tup*_S_ + str;\u000A                  bundle.tuples[ppln][tup].val.cnt = 1;\u000A                  #endif\u000A                }\u000A              }\u000A              bundle.eof = (i == TESTLEN - 1);\u000A              bundle.sel = (bundle.eof) ? agg_ops[r+1] : (int3_t) 0;\u000A\u000A              // \"pipe\" is a type, not a variable.\u000A              switch (str) {\u000A              case 0: {\u000A                TestInputPipe0::write(bundle);\u000A                break;\u000A              }\u000A              #if (_S_ > 1)\u000A              case 1: {\u000A                TestInputPipe1::write(bundle);\u000A                break;\u000A              }\u000A              #endif\u000A              #if (_S_ > 2)\u000A              case 2: {\u000A                TestInputPipe2::write(bundle);\u000A                break;\u000A              }\u000A              #endif\u000A              #if (_S_ > 3)\u000A              case 3: {\u000A                TestInputPipe3::write(bundle);\u000A                break;\u000A              }\u000A              #endif\u000A              }\u000A            }\u000A          }\u000A        } }); });\u000A\u000A    //\u000A    // first string of streaming stages: uniquify->map->aggregate\u000A    //\u000A\u000A    // Merge same-cycle, same-key tuples so keys are unique in each\u000A    // cycle (assumed by the mapper).\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MakeUniqueTask0>([=]()\u000A                                                    { uniquifyStage<AggFunc, TestInputPipe0, UniqueTuplesPipe0, _P_, _N_, _G_>(); }); });\u000A\u000A    // Maps unique keys to indices.  Keys that fails to map (after Gth\u000A    // unique key) is indicated in the mapped field. The\u000A    // map stage can be used in cascade mode where unmapped tuples in\u000A    // the first stage can flow into a second stage.\u000A    // stage to be mapped.\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MapKeyTask0>([=]()\u000A                                                { mapKey2IdxStage<UniqueTuplesPipe0, MappedTuplesPipe0A, _P_, _N_, _G_,\u000A                                                                  0>(); }); });\u000A\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class TraiageMappingTask0>([=]()\u000A                                                        { triageStage<MappedTuplesPipe0A, MappedTuplesPipe0B,\u000A                                                                      UnmappableTuplesPipe0, _P_, _N_, _G_>(); }); });\u000A\u000A    // aggregation tuples according key to idx mapping\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class AggregateTask0>([=]()\u000A                                                   { aggregateStage<AggFunc, MappedTuplesPipe0B, CollectTuplesPipe0, _P_, _N_, _G_>(); }); });\u000A\u000A    // We have to parameterize by S like this because a \"pipe\" is a\u000A    // type, not a variable or object.\u000A    #if (_S_ > 1)\u000A    //\u000A    // second string\u000A    //\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MakeUniqueTask1>([=]()\u000A                                                    { uniquifyStage<AggFunc, TestInputPipe1, UniqueTuplesPipe1, _P_, _N_, _G_>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MapKeyTask1>([=]()\u000A                                                { mapKey2IdxStage<UniqueTuplesPipe1, MappedTuplesPipe1A, _P_, _N_, _G_,\u000A                                                                  0>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class TraiageMappingTask1>([=]()\u000A                                                        { triageStage<MappedTuplesPipe1A, MappedTuplesPipe1B,\u000A                                                                      UnmappableTuplesPipe1, _P_, _N_, _G_>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class AggregateTask1>([=]()\u000A                                                   { aggregateStage<AggFunc, MappedTuplesPipe1B, CollectTuplesPipe1, _P_, _N_, _G_>(); }); });\u000A    #endif\u000A\u000A    #if (_S_ > 2)\u000A    //\u000A    // third string\u000A    //\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MakeUniqueTask2>([=]()\u000A                                                    { uniquifyStage<AggFunc, TestInputPipe2, UniqueTuplesPipe2, _P_, _N_, _G_>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MapKeyTask2>([=]()\u000A                                                { mapKey2IdxStage<UniqueTuplesPipe2, MappedTuplesPipe2A, _P_, _N_, _G_,\u000A                                                                  0>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class TraiageMappingTask2>([=]()\u000A                                                        { triageStage<MappedTuplesPipe2A, MappedTuplesPipe2B,\u000A                                                                      UnmappableTuplesPipe2, _P_, _N_, _G_>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class AggregateTask2>([=]()\u000A                                                   { aggregateStage<AggFunc, MappedTuplesPipe2B, CollectTuplesPipe2, _P_, _N_, _G_>(); }); });\u000A    #endif\u000A\u000A    #if (_S_ > 3)\u000A    //\u000A    // fourth string\u000A    //\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MakeUniqueTask3>([=]()\u000A                                                    { uniquifyStage<AggFunc, TestInputPipe3, UniqueTuplesPipe3, _P_, _N_, _G_>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MapKeyTask3>([=]()\u000A                                                { mapKey2IdxStage<UniqueTuplesPipe3, MappedTuplesPipe3A, _P_, _N_, _G_,\u000A                                                                  0>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class TraiageMappingTask3>([=]()\u000A                                                        { triageStage<MappedTuplesPipe3A, MappedTuplesPipe3B,\u000A                                                                      UnmappableTuplesPipe3, _P_, _N_, _G_>(); }); });\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class AggregateTask3>([=]()\u000A                                                   { aggregateStage<AggFunc, MappedTuplesPipe3B, CollectTuplesPipe3, _P_, _N_, _G_>(); }); });\u000A    #endif\u000A\u000A    q.submit([&](handler &h)\u000A             { h.single_task<class MergeAndAggregateTask>([=]()\u000A                                                          { mergeAggregateStage<AggFunc, CollectTuplesPipe0, CollectTuplesPipe1,\u000A                                                                                CollectTuplesPipe2, CollectTuplesPipe3,\u000A                                                                                UnmappableTuplesPipe0, UnmappableTuplesPipe1,\u000A                                                                                UnmappableTuplesPipe2, UnmappableTuplesPipe3,\u000A                                                                                ReadoutTuplePipe, _S_, _P_, _N_, _G_, OVERSIZE>(); }); });\u000A\u000A    // write to dram to communicate back to host\u000A    auto ev = q.submit([&](handler &h)\u000A                       { h.single_task<class ReadoutTask>([=]()\u000A                                                          {\u000A        for (UINT r = 0; r < ROUNDS; r++) {\u000A          [[intel::initiation_interval(1)]]\u000A          //[[intel::disable_loop_pipelining]]\u000A          for (AggTblIdx grp = 0; grp < (_G_ * OVERSIZE); grp++) {\u000A            Tuple tuple = ReadoutTuplePipe::read();\u000A\u000A            {\u000A              TuplePadded16 tuple16;\u000A              tuple16.valid = tuple.valid;\u000A              tuple16.key = tuple.key;\u000A              tuple16.val = tuple.val;\u000A\u000A              testOutput_device[r * _G_ * OVERSIZE + grp] = tuple16;\u000A            }\u000A          }\u000A        } }); });\u000A\u000A    ev.wait();\u000A  }\u000A  catch (std::exception const &e)\u000A  {\u000A    std::cerr << \"Exception!\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A  auto ev = q.memcpy(testOutput_host, testOutput_device,\u000A                     ROUNDS * _G_ * OVERSIZE * sizeof(TuplePadded16));\u000A  ev.wait();\u000A\u000A// Get end time, if timing\u000A  #if TIMERUN\u000A  gettimeofday(&end, NULL);\u000A  double seconds;\u000A  seconds = (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) * 1e-6;\u000A  printf(\"Execution time: %f seconds\\n\", seconds);\u000A  #endif\u000A\u000A  // Evaluate outputs, check for correctness\u000A  {\u000A    BOOL correct = true;\u000A\u000A    for (UINT r = 0; r < ROUNDS; r++) {\u000A      TuplePadded16 canonical[_G_ * OVERSIZE] = {};\u000A      for (UIDX i = 0; i < (_G_ * OVERSIZE); i++) {\u000A        BOOL valid = testOutput_host[r][i].valid;\u000A        AggKey key = testOutput_host[r][i].key >> 5;\u000A        AggVal sum = testOutput_host[r][i].val;\u000A\u000A        // To support checking, key is randomly generated between 0 and\u000A        // G-1, times 32.  A cheatshet is computed at generation time.\u000A        MY_ASSERT(key < (_G_ * OVERSIZE));\u000A        AggVal answer; answer.val = valid ? cheat[r][key] : 0;\u000A                       answer.cnt = 0;\u000A\u000A        if (valid)\u000A        {\u000A          MY_ASSERT(!canonical[key].valid);\u000A          canonical[key] = testOutput_host[r][i];\u000A          MY_ASSERT((answer.val > 0) ? valid : true);\u000A          correct &= (answer.val == sum.val);\u000A        }\u000A      }\u000A\u000A      printf(\"ROUND %d: \", r);\u000A      printf(\"Aggregating as %s\\n\", ((agg_ops[r] == AVG_OP) ? \"ADD/AVG/CNT\" : ((agg_ops[r] == MIN_OP) ? \"MIN\" : \"MAX\")));\u000A      \u000A      #if 0\u000A        // print out all input pairs\u000A        for (UINT t = 0; t < TESTLEN; t++) {\u000A            for (UINT str = 0; str < _S_; str++) {\u000A              for (UINT ppln = 0; ppln < _P_; ppln++) {\u000A                for (UINT tup = 0; tup < _N_; tup++) {\u000A                  #ifndef SHOW_TUPLE_ID\u000A                  printf(\"(%d,%d) \", testInput_host[r][t][ppln][tup][str].key >> 5, testInput_host[r][t][ppln][tup][str].val.val);\u000A                  #else\u000A                  printf(\"%d:(%d,%d) \", testInput_host[r][t][ppln][tup][str].val.id, testInput_host[r][t][ppln][tup][str].key >> 5, testInput_host[r][t][ppln][tup][str].val.val);\u000A                  #endif\u000A\u000A        }}}}\u000A        printf(\"\\n\");\u000A      #endif\u000A\u000A      for (UIDX i = 0; i < (_G_ * OVERSIZE); i++)\u000A      {\u000A        BOOL valid = canonical[i].valid;\u000A        AggKey key = canonical[i].key >> 5;\u000A        AggVal agg = canonical[i].val;\u000A        AggVal answer; answer.val = valid ? cheat[r][key] : 0;\u000A                       answer.cnt = 0;\u000A\u000A        // Determine cheat count\u000A        if (valid) {\u000A          for (UINT t = 0; t < TESTLEN; t++) {\u000A            for (UINT str = 0; str < _S_; str++) {\u000A              for (UINT ppln = 0; ppln < _P_; ppln++) {\u000A                for (UINT tup = 0; tup < _N_; tup++) {\u000A                  answer.cnt += (canonical[i].key == (testInput_host[r][t][ppln][tup][str].key)) ? 1 : 0;\u000A        }}}}}\u000A\u000A        correct &= (answer.cnt == agg.cnt);\u000A\u000A        bool verbose = 1;\u000A        if (verbose)\u000A          printf(\"(key=%d:valid=%d) \\tkey=%d \\tagg=%d \\tanswer_agg=%d \\tcount=%d \\tanswer_cnt=%d%s%s\\n\", i, valid, key, agg.val, answer.val, agg.cnt, answer.cnt, (agg.val == answer.val) ? \"\" : \" agg mismatch\", (agg.cnt == answer.cnt) ? \"\" : \" count mismatch\");\u000A        else \u000A          printf(\"%s%s\",(agg.val == answer.val) ? \"\" : \" agg mismatch\\n\", (agg.cnt == answer.cnt) ? \"\" : \" count mismatch\\n\");\u000A      }\u000A    }\u000A    fflush(stdout);\u000A    MY_ASSERT(correct);\u000A  }\u000A  return 0;\u000A}\u000A"}, {"path":"/home/wkrska/Aggregation/agg-hls/pipes.h", "name":"pipes.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/agg-hls/pipes.h", "content":"#ifndef PIPES_H\u000A#define PIPES_H\u000A\u000A#define DFLT_PIPE_DEPTH (16)\u000A\u000A#include <sycl/sycl.hpp>\u000Ausing namespace sycl;\u000A\u000A#include \"agg.h\"\u000A\u000Atemplate <int TNumPipeline, int TNumTuple> struct TuplesBundle {\u000A  Tuple tuples[TNumPipeline][TNumTuple];\u000A  BOOL eof;\u000A  int3_t sel;\u000A};\u000A\u000Atemplate <int TNumPipeline, int TNumTuple> struct MappedTuplesBundle {\u000A  Tuple tuples[TNumPipeline][TNumTuple];\u000A  BOOL mapped[TNumPipeline][TNumTuple];\u000A  AggTblIdx idx[TNumPipeline][TNumTuple]; // linear table idx\u000A  BOOL eof;\u000A  int3_t sel; // 3 bit unsigned int for mode select\u000A};\u000A\u000A// pipes from input source (in main.cpp) to uniquify stage\u000Ausing TestInputPipe0 =\u000A    ext::intel::pipe<class pipe0_0, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000Ausing TestInputPipe1 =\u000A    ext::intel::pipe<class pipe0_1, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000Ausing TestInputPipe2 =\u000A    ext::intel::pipe<class pipe0_2, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000Ausing TestInputPipe3 =\u000A    ext::intel::pipe<class pipe0_3, TuplesBundle<_P_, _N_>, DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from uniquify stage to key mapping stage\u000Ausing UniqueTuplesPipe0 =\u000A    ext::intel::pipe<class pipe1_0, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UniqueTuplesPipe1 =\u000A    ext::intel::pipe<class pipe1_1, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UniqueTuplesPipe2 =\u000A    ext::intel::pipe<class pipe1_2, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UniqueTuplesPipe3 =\u000A    ext::intel::pipe<class pipe1_3, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from map stage to triage stage\u000Ausing MappedTuplesPipe0A =\u000A    ext::intel::pipe<class pipe2_0A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe1A =\u000A    ext::intel::pipe<class pipe2_1A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe2A =\u000A    ext::intel::pipe<class pipe2_2A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe3A =\u000A    ext::intel::pipe<class pipe2_3A, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from triage stage to accumulate stage\u000Ausing MappedTuplesPipe0B =\u000A    ext::intel::pipe<class pipe2_0B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe1B =\u000A    ext::intel::pipe<class pipe2_1B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe2B =\u000A    ext::intel::pipe<class pipe2_2B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing MappedTuplesPipe3B =\u000A    ext::intel::pipe<class pipe2_3B, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from triage stage to summation stage\u000Ausing UnmappableTuplesPipe0 =\u000A    ext::intel::pipe<class pipe2_0C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UnmappableTuplesPipe1 =\u000A    ext::intel::pipe<class pipe2_1C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UnmappableTuplesPipe2 =\u000A    ext::intel::pipe<class pipe2_2C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000Ausing UnmappableTuplesPipe3 =\u000A    ext::intel::pipe<class pipe2_3C, MappedTuplesBundle<_P_, _N_>,\u000A                     DFLT_PIPE_DEPTH>;\u000A\u000A// pipes from accumulate stage (final read out) to merge stage\u000Ausing CollectTuplesPipe0 = ext::intel::pipe<class pipe3_0, Tuple, _G_>;\u000Ausing CollectTuplesPipe1 = ext::intel::pipe<class pipe3_1, Tuple, _G_>;\u000Ausing CollectTuplesPipe2 = ext::intel::pipe<class pipe3_2, Tuple, _G_>;\u000Ausing CollectTuplesPipe3 = ext::intel::pipe<class pipe3_3, Tuple, _G_>;\u000A\u000Ausing ReadoutTuplePipe = ext::intel::pipe<class pipe6, Tuple, _G_>;\u000A\u000A#endif\u000A"}, {"path":"/home/wkrska/Aggregation/agg-hls/stages.h", "name":"stages.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/agg-hls/stages.h", "content":"#ifndef STAGES_H\u000A#define STAGES_H\u000A\u000A#include <sycl/sycl.hpp>\u000Ausing namespace sycl;\u000A\u000A#include \"agg.h\"\u000A#include \"core.h\"\u000A#include \"debug.h\"\u000A#include \"pipes.h\"\u000A#include \"types.h\"\u000A#include <functional>\u000A\u000A// All streaming stages follows a common construction based on a main\u000A// ii=1 loops, in many case infinite. An iteration should start every\u000A// cycle, with the sequential loop body pipelined by the compiler to\u000A// overlap many iterations.  The tasks have no arguments.  Only input\u000A// and output are done through pipes.  Because pipes are types,\u000A// template is used to create the semblance of \"pipe arguments\".\u000A\u000A// create unique tuples\u000Atemplate <class AggFunc, typename TTuplesInPipe, typename TTuplesOutPipe, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup>\u000Avoid uniquifyStage() {\u000A  // Variable to store aggregation mode for the frame, default is add/count/average (they all compute the same thing)\u000A  int3_t AggFuncSelect = AVG_OP;\u000A\u000A  while (1) {\u000A    int3_t AggFuncSelect_n;\u000A\u000A    // Repeat until end of frame is reached\u000A    bool eof = false;\u000A    [[intel::initiation_interval(1)]] while (!eof) {\u000A\u000A      TuplesBundle<TNumPipeline, TNumTuple> iBundle = TTuplesInPipe::read();\u000A      [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple> oBundle = {}; // zero out idx!!\u000A\u000A      #pragma unroll\u000A      for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A        collectTuples<AggFunc, TNumTuple, TNumGroup>(AggFuncSelect, iBundle.tuples[ppln], // need to find a way to assign this select value!!!\u000A                                            oBundle.tuples[ppln]);\u000A      }\u000A\u000A      oBundle.eof = iBundle.eof;\u000A      oBundle.sel = iBundle.sel;\u000A\u000A      TTuplesOutPipe::write(oBundle);\u000A\u000A      eof = iBundle.eof;\u000A      AggFuncSelect_n = iBundle.sel;\u000A    }\u000A    AggFuncSelect = AggFuncSelect_n;\u000A  }\u000A}\u000A\u000A// Translate key to idx for use in the aggregate stage. Multiple (M)\u000A// map stages can be used in cascade mode to map M*TNumGroup\u000A// groups. See main.cpp for example.\u000Atemplate <typename TTuplesInPipe, typename TTuplesOutPipe, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup, int TOffset>\u000Avoid mapKey2IdxStage() {\u000A\u000A  MAPPER_DECLARE(TNumPipeline, TNumTuple, TNumGroup, TOffset);\u000A\u000A  [[intel::initiation_interval(1)]] while (1) {\u000A\u000A    [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple> iBundle = TTuplesInPipe::read();\u000A    [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple> oBundle;\u000A\u000A    #pragma unroll\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      // Seems redundant but passing in oBundle.idx and oBundle.mapped\u000A      // directly to map() confuses the compiler analysis somehow\u000A      [[intel::fpga_register]] AggTblIdx idxOut[TNumTuple];\u000A      [[intel::fpga_register]] BOOL mappedOut[TNumTuple] = {};\u000A\u000A      MAPPER_MAP(iBundle.eof, iBundle.tuples[ppln], iBundle.idx[ppln],\u000A                 iBundle.mapped[ppln], idxOut, mappedOut, ppln);\u000A\u000A      // prepare output bundle\u000A      #pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        // set mapper results\u000A        oBundle.idx[ppln][tup] = idxOut[tup];\u000A        oBundle.mapped[ppln][tup] = mappedOut[tup];\u000A      }\u000A\u000A      #pragma unroll\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A        // copy tuples\u000A        oBundle.tuples[ppln][tup] = iBundle.tuples[ppln][tup];\u000A      }\u000A    }\u000A\u000A    oBundle.eof = iBundle.eof;\u000A    oBundle.sel = iBundle.sel;\u000A    TTuplesOutPipe::write(oBundle);\u000A  }\u000A}\u000A\u000A// fork unmappable tuples for special processing\u000Atemplate <typename TTuplesInPipe, typename TTuplesOutPipeMapped,\u000A          typename TTuplesOutPipeUnmapped, int TNumPipeline, int TNumTuple,\u000A          int TNumGroup>\u000Avoid triageStage() {\u000A  [[intel::initiation_interval(1)]] while (1) {\u000A    BOOL unmappable = false;\u000A    MappedTuplesBundle inBundle = TTuplesInPipe::read();\u000A    MappedTuplesBundle<TNumPipeline, TNumTuple> goodBundle = inBundle;\u000A    MappedTuplesBundle<TNumPipeline, TNumTuple> badBundle = inBundle;\u000A\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A\u000A        if (inBundle.tuples[ppln][tup].valid && (!inBundle.mapped[ppln][tup])) {\u000A          goodBundle.tuples[ppln][tup].valid = false;\u000A          badBundle.tuples[ppln][tup].valid = true;\u000A          unmappable = true;\u000A        } else {\u000A          badBundle.tuples[ppln][tup].valid = false;\u000A        }\u000A      }\u000A    }\u000A\u000A    goodBundle.eof = inBundle.eof;\u000A    goodBundle.sel = inBundle.sel;\u000A    badBundle.eof = inBundle.eof;\u000A    badBundle.sel = inBundle.sel;\u000A    TTuplesOutPipeMapped::write(goodBundle);\u000A    if (unmappable || badBundle.eof) {\u000A      TTuplesOutPipeUnmapped::write(badBundle);\u000A    }\u000A  }\u000A}\u000A\u000A// Accumulate tuples until end-of-frame is received; afterwards; read\u000A// out table entries one-by-one to send to next stages\u000Atemplate <class AggFunc, typename TTuplesInPipe, typename TTuplesOutPipe, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup>\u000Avoid aggregateStage() {\u000A\u000A  // This would be neater if aggregator can be done as a class, but we\u000A  // need to control banking of the accumulation table. Compiler won't\u000A  // accept directives in the aggregator class.  Ugly macros are used\u000A  // to hide the ugliness from here.\u000A\u000A  // accumulation table in TNumTuple banks, duplicated for each tuple lane\u000A  AGG_DECLARE(AggFunc, TNumPipeline, TNumTuple, TNumGroup);\u000A\u000A  // Variable to store aggregation mode for the frame, default is add/count/average (they all compute the same thing)\u000A  int3_t AggFuncSelect = AVG_OP;\u000A  // Set \"next\" target based on EOF\u000A  int3_t AggFuncSelect_n = (int3_t) ~0;\u000A\u000A  [[intel::disable_loop_pipelining]] while (1) {\u000A    BOOL done = false;\u000A    BOOL done_ = false;\u000A    BOOL done__ = false;\u000A    \u000A    AGG_INIT_TABLE(AggFuncSelect);\u000A\u000A    // main loop, iterate until end-of-frame arrives\u000A    [[intel::initiation_interval(1)]] while (!done) {\u000A      BOOL iValid = false;\u000A      [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple> iBundle;\u000A\u000A      // go round 2 more times without fetching new bundle to finish\u000A      // deferred updates\u000A      done = done_;\u000A      done_ = done__;\u000A\u000A      if (!done__) {\u000A        iBundle = TTuplesInPipe::read(iValid);\u000A      }\u000A\u000A      #pragma unroll\u000A      for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A        #pragma unroll\u000A        for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A          iBundle.tuples[ppln][tup].valid &= iValid;\u000A        }\u000A        AGG_UPDATE(AggFuncSelect, iBundle.tuples[ppln], iBundle.idx[ppln], ppln);\u000A      }\u000A\u000A      if (iValid) {\u000A        if (iBundle.eof) {\u000A          done__ = true;\u000A          AggFuncSelect_n = iBundle.sel;\u000A        }\u000A      }\u000A    }\u000A    // read back accumulated values and send forward\u000A    [[intel::disable_loop_pipelining]] for (UIDX grp = 0; grp < TNumGroup; grp++) {\u000A      Tuple tuples[TNumPipeline] = {};\u000A      AGG_READ(AggFuncSelect, grp, tuples);\u000A      [[intel::disable_loop_pipelining]] for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A        TTuplesOutPipe::write(tuples[ppln]);\u000A      }\u000A    }\u000A  AggFuncSelect = AggFuncSelect_n;\u000A  }\u000A}\u000A\u000Atemplate <class AggFunc, int TNumGroup, int TOversize>\u000Avoid seqAccumulate(int AggFuncSelect, bool &firstItr, Tuple tuple, TuplePadded16 table[TNumGroup * TOversize]) {\u000A  BOOL found = 0;\u000A  if (tuple.valid) {\u000A    [[intel::disable_loop_pipelining]] for (AggTblIdx grp = 0; grp < (TNumGroup * TOversize); grp++) {\u000A      if (firstItr)\u000A        AggFunc::init(table[grp].val, AggFuncSelect); // Initialize output values\u000A      TuplePadded16 entry = table[grp];\u000A      if (entry.valid) {\u000A        if (tuple.key == entry.key) {\u000A          AggFunc::run(entry.val, tuple.val, AggFuncSelect);\u000A          table[grp] = entry;\u000A          found = true;\u000A          break;\u000A        }\u000A      } else {\u000A        entry.valid = true;\u000A        entry.key = tuple.key;\u000A        entry.val.val = tuple.val.val;\u000A        entry.val.cnt = tuple.val.cnt;\u000A        table[grp] = entry;\u000A        found = true;\u000A        break;\u000A      }\u000A    }\u000A    firstItr = false;\u000A    MY_ASSERT(found);\u000A  }\u000A}\u000A\u000A// Merge readback from S strings of aggregation into 1 string. No need\u000A// to go fast. This happens offline, in between sessions.\u000Atemplate <class AggFunc,\u000A          typename TTuplesInPipe0Summary, typename TTuplesInPipe1Summary,\u000A          typename TTuplesInPipe2Summary, typename TTuplesInPipe3Summary,\u000A          typename TTuplesInPipe0Unmapped, typename TTuplesInPipe1Unmapped,\u000A          typename TTuplesInPipe2Unmapped, typename TTuplesInPipe3Unmapped,\u000A          typename TTuplesOutPipe, int TNumString, int TNumPipeline,\u000A          int TNumTuple, int TNumGroup, int TOversize>\u000Avoid mergeAggregateStage() {\u000A  [[intel::fpga_memory(\"BLOCK_RAM\"), intel::singlepump, intel::simple_dual_port, /*intel::max_replicates(1),intel::numbanks(1)*/]] TuplePadded16 table[TNumGroup * TOversize];\u000A\u000A  // Variable to store aggregation mode for the frame, default is add/count/average (they all compute the same thing)\u000A  int3_t AggFuncSelect = AVG_OP;\u000A  int3_t AggFuncSelect_n = (int3_t) ~0;\u000A\u000A  [[intel::disable_loop_pipelining]] while (1) {\u000A    [[intel::disable_loop_pipelining]] for (AggTblIdx grp = 0; grp < (TNumGroup * TOversize); grp++) {\u000A      table[grp] = {};\u000A      AggFunc::init(table[grp].val, AggFuncSelect);\u000A    }\u000A\u000A    BOOL firstItr = true;\u000A\u000A    UIDX str = 0;\u000A    UIDX eofCnt = 0;\u000A    BOOL eof[TNumString] = {};\u000A\u000A    while (eofCnt != TNumString) {\u000A      if (!eof[str]) {\u000A        BOOL valid = false;\u000A        [[intel::fpga_register]] MappedTuplesBundle<TNumPipeline, TNumTuple> bundle;\u000A\u000A        switch (str) {\u000A          case 0: {\u000A            bundle = TTuplesInPipe0Unmapped::read(valid);\u000A            break;\u000A          }\u000A          #if (_S_ > 1)\u000A          case 1: {\u000A            bundle = TTuplesInPipe1Unmapped::read(valid);\u000A            break;\u000A          }\u000A          #endif\u000A          #if (_S_ > 2)\u000A          case 2: {\u000A            bundle = TTuplesInPipe2Unmapped::read(valid);\u000A            break;\u000A          }\u000A          #endif\u000A          #if (_S_ > 3)\u000A          case 3: {\u000A            bundle = TTuplesInPipe3Unmapped::read(valid);\u000A            break;\u000A          }\u000A          #endif\u000A        }\u000A\u000A        if (valid) {\u000A          for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A            for (UIDX tup = 0; tup < TNumTuple; tup++) {\u000A              seqAccumulate<AggFunc, TNumGroup, TOversize>(AggFuncSelect, firstItr, bundle.tuples[ppln][tup], table);\u000A            }\u000A          }\u000A          if (bundle.eof) {\u000A            AggFuncSelect_n = bundle.sel;\u000A            eofCnt++;\u000A            eof[str] = true;\u000A          }\u000A        }\u000A      }\u000A\u000A      str++;\u000A      str %= TNumString;\u000A    }\u000A    \u000A    // expecting G readbacks per string\u000A    for (UIDX ppln = 0; ppln < TNumPipeline; ppln++) {\u000A      for (AggTblIdx grp = 0; grp < TNumGroup; grp++) {\u000A        for (UIDX str = 0; str < TNumString; str++) {\u000A          Tuple tuple = {};\u000A\u000A          switch (str) {\u000A          case 0: {\u000A            tuple = TTuplesInPipe0Summary::read();\u000A            break;\u000A          }\u000A          #if (_S_ > 1)\u000A          case 1: {\u000A            tuple = TTuplesInPipe1Summary::read();\u000A            break;\u000A          }\u000A          #endif\u000A          #if (_S_ > 2)\u000A          case 2: {\u000A            tuple = TTuplesInPipe2Summary::read();\u000A            break;\u000A          }\u000A          #endif\u000A          #if (_S_ > 3)\u000A          case 3: {\u000A            tuple = TTuplesInPipe3Summary::read();\u000A            break;\u000A          }\u000A          #endif\u000A          }\u000A\u000A          seqAccumulate<AggFunc, TNumGroup, TOversize>(AggFuncSelect, firstItr, tuple, table);\u000A        }\u000A      }\u000A    } // ppln\u000A\u000A    for (AggTblIdx grp = 0; grp < (TNumGroup * TOversize); grp++) {\u000A      TuplePadded16 tr = table[grp];\u000A      Tuple tw;\u000A      tw.valid = tr.valid;\u000A      tw.key = tr.key;\u000A      tw.val.val = tr.val.val;\u000A      tw.val.cnt = tr.val.cnt;\u000A      TTuplesOutPipe::write(tw);\u000A    }\u000A    AggFuncSelect = AggFuncSelect_n;\u000A  } // while(1)\u000A}\u000A\u000A#ifdef SHOW_DEPRECATED\u000A#include \"stages_.h\"\u000A#endif\u000A\u000A#endif\u000A"}, {"path":"/ofs_install/oneapi/2023.2/tbb/2021.10.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/ofs_install/oneapi/2023.2/tbb/2021.10.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}, {"path":"/home/wkrska/Aggregation/agg-hls/types.h", "name":"types.h", "has_active_debug_locs":false, "absName":"/home/wkrska/Aggregation/agg-hls/types.h", "content":"#ifndef TYPES_H\u000A#define TYPES_H\u000A\u000A//\u000A// standard stuff: redefine as necessary for HLS\u000A//\u000A\u000A#define BITSINBYTE (8)\u000A#define BYTEMASK ((1 << BITSINBYTE) - 1)\u000A#define LGBITSINBYTE (3)\u000A\u000Atypedef unsigned char UBYTE; // a byte\u000Atypedef bool BOOL;           // stand-in for Boolean\u000A\u000Atypedef unsigned short UIDX; // small index for HW loops: 64k is enough\u000Atypedef unsigned int UIDXL;  // large index for data loops\u000A\u000Atypedef unsigned long ULONG;   // 8-byte generic\u000Atypedef unsigned short USHORT; // 2-byte generic\u000Atypedef unsigned char UCHAR;   // 1-byte generic\u000A\u000Atypedef int INT;\u000Atypedef unsigned int UINT;\u000A\u000A#endif\u000A"}]